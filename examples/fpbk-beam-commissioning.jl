#=
    Commissioning a beam for the Finite Pencil Beam Kernel

This script will commission a beam for the `FinitePencilBeamKernel` dose calculation
algorithm. It reads water phantom data from "examples/sample-data/water-tank-dose.hdf5",
which is either measured by experiment, or generated by a Monte-Carlo simulation.
It stores the commissioned kernel in "examples/sample-data/dose-kernel/finite-pencil-beam-kernel.hdf5"
=#

using DoseCalculations
using Plots, StaticArrays
using Interpolations, LsqFit, HDF5
using Statistics, Printf

#--- Set Parameters ------------------------------------------------------------

SSD = 1000.
SAD = SSD
fieldsize = 120.

#---  Load Data ----------------------------------------------------------------

begin
    dosefilepath = "examples/sample-data/water-tank-dose.hdf5"
    x, depth, measured_dose = h5open(dosefilepath, "r") do fid
        x = read(fid["x"])
        z = read(fid["depth"])
        dose = read(fid["dose/fieldsize-$(Int(fieldsize))mm"])
        
        x, z, dose
    end
end

heatmap(x, depth, measured_dose', title="Measured Dose",
        xlabel="Off-Axis Position (mm)", ylabel="Depth (mm)")

#--- Fit Steepness and Weight Parameters ---------------------------------------

# Extract depth profiles:
# 1. Scale to isocenter
# 2. Truncate scaled position 
# 3. Scale dose by maximum dose

function extract_profile(x, dose, depth, SAD; normalize=true, xiso_max=100.)
    x′ = x*SAD/(SAD+depth)
    i = @. -xiso_max<=x′<=xiso_max
    log_dose = log.(dose[i])
    if normalize
        log_dose .-= log(maximum(dose))
    end
        
    x′[i], log_dose
end

function extract_profiles(x, dose, depth, SAD; kwargs...)
    extract_profile.(Ref(x), eachcol(dose), depth, SAD; kwargs...)
end


xiso_max = 120. *0.9
profiles = extract_profiles(x, measured_dose, depth, SAD; xiso_max=xiso_max)

begin
    plt = plot()
    for i in eachindex(profiles)[1:10:end]
        x′, dose = profiles[i]
        plot!(plt, x′, dose, label=@sprintf "%0.0fmm" depth[i])
    end
    plt
end

# Create Model

profile_at_depth(x, w, ux, x₀) = DoseCalculations.fpbk_dose(x, 0., w, ux, ux, x₀, x₀)

function model(x, p, fieldsize)
    a = p[1]
    w = p[2]
    ux = @view p[3:4]

    log(a) .+ log.(profile_at_depth.(x, w, Ref(ux), 0.5*fieldsize))
end

# Least Squares Fit

function fit_profile(x′, log_dose, fieldsize)
    p0 = [1., 0.2, 0.03, 0.4]

    lb = [-Inf, 0., 0., 0.]
    ub = [Inf, 1., Inf, Inf]


    fit = curve_fit((x, p)->model(x, p, fieldsize),
                    x′, log_dose, p0,
                    lower=lb, upper=ub)

    !fit.converged && return fill(NaN, 4), fill(NaN, 4)

    a, w, ux1, ux2 = fit.param
    errors = standard_errors(fit)
    if(ux1>ux2)
        w = 1-w
        ux1, ux2 = ux2, ux1
    end
    [a, w, ux1, ux2], errors
end

# Fit parameters
begin
    params = zeros(4, length(depth))
    errors = zeros(4, length(depth))
    for (i, profile) in enumerate(profiles)
        p, ε = fit_profile(profile[1], profile[2], fieldsize)
        params[:, i] .= p
        errors[:, i] .= ε
    end
end

function plot_params!(plts, depth, params)
    ylabels = ["a", "w", "ux₁", "ux₂"]
    for i in eachindex(plts)
        plot!(plts[i], depth, params[i, :], legend=false, ylabel=ylabels[i])
    end
    plts
end
plot_params(depth, params) = plot_params!([plot() for _ in 1:4], depth, params)

plts = plot_params(depth, params)
plot(plts..., layout=grid(2, 2), figheight=(12, 5))

#--- Smooth -------------------------------------------------------------------

"""
    poly(x::Number, p)

Compute the polynomial at `x` with coefficients `p`
"""
function poly(x::Number, p)
    n = 0:length(p)-1
    sum(@. p*x^n)
end

function poly(x, p)
    n = (1:length(p)).-1
    vec(sum(@. p*x'^n; dims=1))
end

"""
    fitpoly(x, y, order)

Fit an `order` polynomial y=f(x).

Returns the coefficients.
"""
function fitpoly(x, y, order)
    p₀ = zeros(order+1)
    fit = curve_fit(poly, x, y, p₀)
    fit.param
end


"""
    smooth(x, y, nwindow, polyorder=2)

Smooth `y` using a Savitzky–Golay filter of order `polyorder`.
"""
function smooth(x, y, nwindow, polyorder=2)

    @assert isodd(nwindow) "nwindow must be odd"
    @assert nwindow>polyorder+1 "nwindow must be greater than polyorder+1"

    ynew = zeros(length(y))

    hn = nwindow÷2
    N = length(y)
    
    for i in eachindex(x, y, ynew)

        i0 = clamp(i-hn, 1, N-nwindow÷2+1)
        i1 = clamp(i+hn, nwindow÷2, N)

        xi = x[i0:i1]
        yi = y[i0:i1]

        isresult = @. !ismissing(yi)

        # Fit Polynomial
        coeff = fitpoly((@view xi[isresult]), (@view yi[isresult]), polyorder)

        # Calculate ynew
        ynew[i] = poly(x[i], coeff)
    end
    ynew
end

params_s = hcat(smooth.(Ref(depth), eachrow(params), 51)...)'
plot_params!(plts, depth, params_s)
plot(plts..., layout=grid(2, 2), figheight=(12, 5))

begin
    k = searchsortedlast(depth, 200.)
    x′, dose′ = profiles[k]

    plt = plot(xlabel="Scaled Off-Axis Position (mm)", ylabel="Dose (Scaled)",)
            #    title=@sprintf "Depth %0.0fmm" depth[k])
    plot!(plt, x′, dose′, label="Measured")

    a = params_s[1, k]
    w = params_s[2, k]
    ux = params_s[3:4, k]

    prof = a*profile_at_depth.(x′, w, Ref(ux), 0.5*fieldsize)
    plot!(plt, x′, log.(prof), label="Fitted")
end

#--- Compute Scaling Factor ---------------------------------------------------

R = @. depth + SAD

tanθmax = xiso_max/SAD
tanθ = range(0., tanθmax, length=101)

function scaling_factor(tanθ, d, R, D, param, SAD)

    secθ = √(tanθ^2 + 1)

    d′ = d*secθ
    R′ = R*secθ

    w, ux1, ux2 = param(d′)

    x′ = SAD*tanθ
    F = profile_at_depth(x′, w, SVector(ux1, ux2), 0.5*fieldsize)
    exp(D(x′))*R′^2/F
end

# Set up Interpolators for parameters and measured dose
p = SVector{3}.(eachcol(params[2:4, :]))
p = linear_interpolation(depth, p, extrapolation_bc=Flat())


unscaled_profiles = extract_profiles(x, measured_dose, depth, SAD; normalize=false, xiso_max=xiso_max)
D = linear_interpolation.(getindex.(profiles, 1), getindex.(unscaled_profiles, 2), extrapolation_bc=Line())

# Compute Scaling Factor
A = scaling_factor.(tanθ', depth, R, D, Ref(p), SAD)

heatmap(tanθ, depth, A, xlabel="tan(θ)", ylabel="Depth (mm)")

#--- Verify Result ------------------------------------------------------------

# Create Kernel
parameters = vcat(params[2:end, :], params[3:4, :])

calc = FinitePencilBeamKernel(depth, parameters, tanθ, A)
calibrate!(calc, 1., fieldsize, SAD; beamlet_size=5.)

# Create dose positions, external surface, gantry and beamlet
pos = @. SVector(x, 0., -depth')
surf = PlaneSurface(SSD)
gantry = GantryPosition(0., 0., SAD)

xb = -0.5*fieldsize:5.:0.5*fieldsize
bixels = bixel_grid(xb, xb)
beamlets = Beamlet.(bixels, (gantry,))

# Compute dose
using Tullio
@tullio dose[i, j] := DoseCalculations.point_dose(pos[i, j], beamlets[n, m], surf, calc)

# Calculate error
√sum(@. (dose-measured_dose)^2)

# Plot
heatmap(x, depth, measured_dose', xlabel="x (mm)", ylabel="Depth (mm)",
        title="Measured Dose", aspect_ratio=1)

heatmap(x, depth, dose', xlabel="x (mm)", ylabel="Depth (mm)",
        title="Computed Dose", aspect_ratio=1)

function diff_heatmap!(plt, x, y, f; clim = maximum(abs.(f)), kwargs...)
    heatmap!(plt, x, y, f; clim=clim.*(-1, 1), kwargs...)
end
diff_heatmap(args...; kwargs...) = diff_heatmap!(plot(), args...; kwargs...)

Δdose = dose-measured_dose

diff_heatmap(x, depth, Δdose'*100,
             c=reverse(cgrad(:RdBu)),
             xlim=x[[1, end]], ylim=depth[[1, end]],
             xlabel="x (mm)", ylabel="Depth (mm)",
             title="Measured Dose", aspect_ratio=1)

begin
    depths = [50., 100., 150., 250.]
    plt = plot(xlabel="x (mm)", ylabel="Dose")
    for (i, d) in enumerate(depths)
        k = searchsortedlast(depth, d)
        plot!(plt, x, dose[:, k], color=i, label=@sprintf "depth=%0.0fmm" d)
        plot!(plt, x, measured_dose[:, k], color=i, linestyle=:dash, label="")
    end
    plot(plt, yscale=:log10, xlim=[0., 280.], ylim=[1e-2, 1.])
end

#--- Save to File --------------------------------------------------------------



using JLD2
filename = @sprintf "examples/sample-data/fpbk-fieldsize_%imm.jld2" fieldsize
JLD2.save(filename, Dict("parameters"=>parameters,
                         "depth"=>depth,
                         "scalingfactor"=>A,
                         "tantheta"=>tanθ))



