var documenterSearchIndex = {"docs":
[{"location":"Structures/#Structures","page":"Structures","title":"Structures","text":"","category":"section"},{"location":"Structures/","page":"Structures","title":"Structures","text":"Dose volumes often contain structures of interest (e.g. the PTV or an OAR) where one may want to compute dose, or determine various metrics.","category":"page"},{"location":"Structures/","page":"Structures","title":"Structures","text":"This section describes how to use structures to:","category":"page"},{"location":"Structures/","page":"Structures","title":"Structures","text":"Load structures from file.\nCreate dose points within a given structure \nTag dose points based on which structure they are in.","category":"page"},{"location":"Structures/#Creating-Structures","page":"Structures","title":"Creating Structures","text":"","category":"section"},{"location":"Structures/","page":"Structures","title":"Structures","text":"One can load a mesh file using load_structure_from_ply. Currently, only .ply files are supported.","category":"page"},{"location":"Structures/","page":"Structures","title":"Structures","text":"structure = load_structure_from_ply(\"mesh.ply\")","category":"page"},{"location":"Structures/","page":"Structures","title":"Structures","text":"This returns a Meshes.SimpleMesh, as provided by Meshes.jl.","category":"page"},{"location":"Structures/","page":"Structures","title":"Structures","text":"Currently, loading structures direct from a DICOM RT Structure Set is not supported. Structures stored in DICOM files are not in a \"friendly\" mesh format, and usually require some modification before they can be used. There are many tools available which convert DICOM structures into a suitable mesh file (e.g. 3D Slicer).","category":"page"},{"location":"Structures/#Coordinate-Transformations","page":"Structures","title":"Coordinate Transformations","text":"","category":"section"},{"location":"Structures/","page":"Structures","title":"Structures","text":"One can apply general transformations to any structure by calling the transform or transform! function:","category":"page"},{"location":"Structures/","page":"Structures","title":"Structures","text":"T = fixed_to_bld(0., 0., 1000.)\ntransform(structure, T)","category":"page"},{"location":"Structures/","page":"Structures","title":"Structures","text":"T is a general transformation as provided by CoordinateTransformations.jl. In this example, the helper function fixed_to_bld is used to create a transformation from the IEC Fixed to IEC BLD coordinate system. See Coordinate Transformations for more details.","category":"page"},{"location":"ExternalSurfaces/#External-Surfaces","page":"External Surfaces","title":"External Surfaces","text":"","category":"section"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"This library provides an interface to provide an external surface, which is used for source-surface distance (SSD) and depth calculations. Physically, the external surface denotes the boundary between air and the dose absorbing medium (e.g. the patient's skin or the surface of a phantom).","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"All external surfaces are subtypes of AbstractExternalSurface, which exposes two methods:","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"getSSD(surf, p): Returns distance between the surface and the source for a given position in the dose volume (p)\ngetdepth(surf, p): Returns the depth of a given position in the dose volume (p)","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"Both of these methods take an external surface (surf) and a dose point position (pᵢ). The position is usually a location where dose is computed, and is a three-element vector in the IEC Beam-Limiting-Device (BLD) coordinate system.","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"All surfaces are assumed to be in the IEC BLD coordinate system. This means that they must undergo coordinate transformation in order to account for gantry and/or collimator rotation.","category":"page"},{"location":"ExternalSurfaces/#Types-of-External-Surface","page":"External Surfaces","title":"Types of External Surface","text":"","category":"section"},{"location":"ExternalSurfaces/#Plane-Surface","page":"External Surfaces","title":"Plane Surface","text":"","category":"section"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"A simple plane surface, positioned at a constant source-surface distance along the central beam axis with normal pointed towards the source. It accounts the fact that SSD increases with off-axis position.","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"using DoseCalculations\nsurf = PlaneSurface(800.)\ngetSSD(surf, [0., 0., 810.])\ngetSSD(surf, [10., 20., 810.])","category":"page"},{"location":"ExternalSurfaces/#Mesh-Surface","page":"External Surfaces","title":"Mesh Surface","text":"","category":"section"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"A general surface as defined by a 3D mesh provided by the user.","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"This surface is created by suppling a 3D mesh,","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"MeshSurface(mesh)","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"which can be read from a .ply file, as described in Structures","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"This is considered a slow method: for each position in the dose volume, it iterates through every face in the mesh (see DoseCalculations.intersect_mesh). A better alternative would be to create an Isoplane Surface.","category":"page"},{"location":"ExternalSurfaces/#Isoplane-Surface","page":"External Surfaces","title":"Isoplane Surface","text":"","category":"section"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"An isoplane surface collapses a general surface onto a plane centred at the isocentre with normal towards the source. It stores source-surface distances for points on the isoplane. The position of these points are determined by a pre-defined grid.","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"This makes use of the fact that the distance between source and surface does not change along ray-lines.","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"The Isoplane surface can be constructed by specifying either the x and y axes of the grid,","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"IsoplaneSurface(x, y, SAD)","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"or by specifying dose volume positions (pos), and plane grid spacings Δx and Δy.","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"IsoplaneSurface(pos, Δx, Δy, SAD)","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"In this case, the extent of the grid is computed from dose volume positions.","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"The SSD values on the plane are computed from a mesh_surf::DoseCalculations.MeshSurface,","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"compute_SSD!(surf, mesh_surf)","category":"page"},{"location":"ExternalSurfaces/#Constant-Surface","page":"External Surfaces","title":"Constant Surface","text":"","category":"section"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"A constant surface simply returns the provided source-surface distance, regardless of position.","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"using DoseCalculations\nsurf = ConstantSurface(800.)\ngetSSD(surf, [0., 0., 810.])\ngetSSD(surf, [10., 20., 810.])","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"While such a surface is technically possible to implement in reality, this surface is largely used for debug purposes.","category":"page"},{"location":"ScaledIsoplaneKernel/#Scaled-Isoplane-Kernel","page":"Scaled Isoplane Kernel","title":"Scaled Isoplane Kernel","text":"","category":"section"},{"location":"ScaledIsoplaneKernel/","page":"Scaled Isoplane Kernel","title":"Scaled Isoplane Kernel","text":"The Scaled Isoplane Dose Calculation Kernel is a simplified pencil beam kernel algorithm. It only uses 1 single pencil beam kernel for a given field size (typically 10 x 10 cm²). It then scales the dose by using the measured percentage depth dose combined with a few correction factors. More details can be found in the original paper.","category":"page"},{"location":"ScaledIsoplaneKernel/#Data","page":"Scaled Isoplane Kernel","title":"Data","text":"","category":"section"},{"location":"ScaledIsoplaneKernel/","page":"Scaled Isoplane Kernel","title":"Scaled Isoplane Kernel","text":"Example kernel data is located in examples/sample-data/dose-kernel/scaled-isoplane-kernel.json. This data specification is as follows:","category":"page"},{"location":"ScaledIsoplaneKernel/","page":"Scaled Isoplane Kernel","title":"Scaled Isoplane Kernel","text":"Energy: Beam energy (e.g. \"6MV\")\nKernel\nSSD: Source Surface Distance in mm\nRadius: Array of off-axis distance (radius) in mm\nKernel Value: Array of kernel values at specified radius\nDepth Dose\nSSD: Source Surface Distance in mm\nField Size: Field size of measured depth dose\nDepth: Array of depths below surface in mm\nDose: Dose at specified depths, normalised to 1","category":"page"},{"location":"ScaledIsoplaneKernel/","page":"Scaled Isoplane Kernel","title":"Scaled Isoplane Kernel","text":"<!– | File | Info | |:––-|:––-|  | - Energy | Beam energy (e.g. \"6MV\") | | - Kernel | | |   - SSD | Source Surface Distance in mm | |   - Radius | Array of off-axis distance (radius) in mm | |   - Kernel Value | Array of kernel values at specified radius | –>","category":"page"},{"location":"#DoseCalculations.jl","page":"DoseCalculations.jl","title":"DoseCalculations.jl","text":"","category":"section"},{"location":"","page":"DoseCalculations.jl","title":"DoseCalculations.jl","text":"This is a Julia package for computing radiotherapy doses. The aim of this package is to provide a general and extensible means to include dose calculations into research. Examples of this include:","category":"page"},{"location":"","page":"DoseCalculations.jl","title":"DoseCalculations.jl","text":"Novel treatment planning methods\nDose-based adaptive radiotherapy\nDosimetric assessment of adaptive radiotherapy","category":"page"},{"location":"","page":"DoseCalculations.jl","title":"DoseCalculations.jl","text":"(Image: dose_recon_example)","category":"page"},{"location":"API/","page":"-","title":"-","text":"Modules = [DoseCalculations]","category":"page"},{"location":"API/#DoseCalculations.AbstractBeamLimitingDevice","page":"-","title":"DoseCalculations.AbstractBeamLimitingDevice","text":"Abstract type for Beam Limiting Devices are based on\n\nAbstractBeamLimitingDevice contains the types for MultiLeafCollimators, Jaws, etc.\n\n\n\n\n\n","category":"type"},{"location":"API/#DoseCalculations.AbstractBixel","page":"-","title":"DoseCalculations.AbstractBixel","text":"AbstractBixel\n\n\n\n\n\n","category":"type"},{"location":"API/#DoseCalculations.AbstractDoseGrid","page":"-","title":"DoseCalculations.AbstractDoseGrid","text":"AbstractDoseGrid <: DosePositions\n\nA type of Dose Positions on a regular grid.\n\nMust have the fields x, y, and z.\n\n\n\n\n\n","category":"type"},{"location":"API/#DoseCalculations.AbstractExternalSurface","page":"-","title":"DoseCalculations.AbstractExternalSurface","text":"AbstractExternalSurface\n\nSupertype for external surfaces.\n\n\n\n\n\n","category":"type"},{"location":"API/#DoseCalculations.AbstractFluenceElement","page":"-","title":"DoseCalculations.AbstractFluenceElement","text":"AbstractFluenceElement\n\n\n\n\n\n","category":"type"},{"location":"API/#DoseCalculations.AbstractTreatmentField","page":"-","title":"DoseCalculations.AbstractTreatmentField","text":"Treatment Field\n\nAbstract treatment field, basis for containing multiple treatment types (e.g. VMAT, IMRT, etc.)\n\n\n\n\n\n","category":"type"},{"location":"API/#DoseCalculations.Beamlet-Tuple{Bixel, GantryPosition}","page":"-","title":"DoseCalculations.Beamlet","text":"Beamlet(bixel::Bixel, gantry)\n\nConstruct a beamlet from a bixel\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.Bixel","page":"-","title":"DoseCalculations.Bixel","text":"Bixel{T}\n\n\n\n\n\n","category":"type"},{"location":"API/#DoseCalculations.ConstantSurface","page":"-","title":"DoseCalculations.ConstantSurface","text":"ConstantSurface\n\nAn external surface with a constant source surface distance, regardless of the position. This surface is largely used for testing purposes as its inherently unphysical.\n\n\n\n\n\n","category":"type"},{"location":"API/#DoseCalculations.CylinderBounds","page":"-","title":"DoseCalculations.CylinderBounds","text":"CylinderBounds{T}\n\nRepresents a cylinder about the z axis.\n\n\n\n\n\n","category":"type"},{"location":"API/#DoseCalculations.CylindricalSurface","page":"-","title":"DoseCalculations.CylindricalSurface","text":"CylindricalSurface\n\nA planar external surface at a variable distance from the isocenter.\n\n\n\n\n\n","category":"type"},{"location":"API/#DoseCalculations.CylindricalSurface-Tuple{Meshes.SimpleMesh}","page":"-","title":"DoseCalculations.CylindricalSurface","text":"CylindricalSurface\n\nConstruct from a mesh.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.DoseGrid","page":"-","title":"DoseCalculations.DoseGrid","text":"DoseGrid\n\nCartesian Dose Grid\n\n\n\n\n\n","category":"type"},{"location":"API/#DoseCalculations.DoseGrid-2","page":"-","title":"DoseCalculations.DoseGrid","text":"DoseGrid(Δ, bounds::AbstractBounds)\n\nConstruct a DoseGrid with spacing Δ within bounds.\n\nCan specify a coordinate system transformation in transform to generate dose points in a different coordinate system to the bounds.\n\n\n\n\n\n","category":"type"},{"location":"API/#DoseCalculations.DoseGridMasked","page":"-","title":"DoseCalculations.DoseGridMasked","text":"DoseGridMasked\n\nCartesian Dose Grid with a mask to reduce the number of dose points used.\n\n\n\n\n\n","category":"type"},{"location":"API/#DoseCalculations.DoseGridMasked-2","page":"-","title":"DoseCalculations.DoseGridMasked","text":"DoseGridMasked(Δ, bounds::AbstractBounds, transform=I)\n\nConstruct a DoseGridMasked with spacing Δ within bounds.\n\nThe mask applies to all points within bounds. Can specify a coordinate system transformation in transform to generate dose points in a different coordinate system to the bounds.\n\n\n\n\n\n","category":"type"},{"location":"API/#DoseCalculations.GantryPosition","page":"-","title":"DoseCalculations.GantryPosition","text":"GantryPosition{T}\n\nThe position/rotation of the gantry and beam-limiting device.\n\nStores:\n\ngantry_angle: As defined by IEC\ncollimator_angle: As defined by IEC (beam limiting device angle)\nsource_axis_distance: Distance between source and isocenter\ncentral_beam_axis: Unit vector pointing from the isocenter to the source in IEC Fixed coordinates.\n\n\n\n\n\n","category":"type"},{"location":"API/#DoseCalculations.Jaws","page":"-","title":"DoseCalculations.Jaws","text":"Jaws\n\nJaws stores the x and y positions of the jaws.\n\nThe x/y positions of the jaws can be accessed through the getx/gety methods.\n\nThe usual constructor directly takes the jaw x and y position vectors, but a single fieldsize can also be specified.\n\n\n\n\n\n","category":"type"},{"location":"API/#DoseCalculations.Jaws-Tuple{T} where T<:AbstractFloat","page":"-","title":"DoseCalculations.Jaws","text":"Jaws(fieldsize::T)\n\nCreate jaws with a square field of length fieldsize.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.MeshBounds","page":"-","title":"DoseCalculations.MeshBounds","text":"MeshBounds{T, TMesh}\n\nRepresents a surface from a mesh.\n\n\n\n\n\n","category":"type"},{"location":"API/#DoseCalculations.MeshSurface","page":"-","title":"DoseCalculations.MeshSurface","text":"MeshSurface\n\nAn external surface defined by a 3D mesh.\n\n\n\n\n\n","category":"type"},{"location":"API/#DoseCalculations.MultiLeafCollimator","page":"-","title":"DoseCalculations.MultiLeafCollimator","text":"MultiLeafCollimator\n\nMultiLeafCollimator stores the leaf positions and edges of an MLC.\n\nThe 2 by n leaf positions are stored in the positions matrix. The leaf position boundaries are stored in the edges vector, which is 1 element longer than the number of leaf tracks, n.\n\nIndexing a MultiLeafCollimator will either return the x and y bounds of the leaf track, or another MultiLeafCollimator. It also supports the @view macro. Iteration goes through each leaf track, returning the lower and upper boundaries.\n\nA MultiLeafCollimator can also be shifted through addition or subtraction, and scaled with multplication and division.\n\nThe locate method is implemented to return the leaf index containing edge position.\n\n\n\n\n\n","category":"type"},{"location":"API/#DoseCalculations.MultiLeafCollimator-Tuple{Any}","page":"-","title":"DoseCalculations.MultiLeafCollimator","text":"MultiLeafCollimator(n::Int, Δy::Real)\n\nConstruct an MLC with leaf edges.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.MultiLeafCollimator-Tuple{Int64, Real}","page":"-","title":"DoseCalculations.MultiLeafCollimator","text":"MultiLeafCollimator(n::Int, Δy::Real)\n\nConstruct an MLC with n number of leaves and of leaf width Δy, centered about zero.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.MultiLeafCollimatorSequence","page":"-","title":"DoseCalculations.MultiLeafCollimatorSequence","text":"MultiLeafCollimatorSequence\n\nMultiLeafCollimatorSequence stores a sequence of MLC apertures.\n\nThe 2 by n leaf positions are stored in the positions matrix. The leaf position boundaries are stored in the edges vector, which is 1 element longer than the number of leaf tracks, n.\n\nIndexing a MultiLeafCollimator will either return the x and y bounds of the leaf track, or another MultiLeafCollimator. It also supports the @view macro. Iteration goes through each leaf track, returning the lower and upper boundaries.\n\nA MultiLeafCollimator can also be shifted through addition or subtraction, and scaled with multplication and division.\n\nThe locate method is implemented to return the leaf index containing edge position.\n\n\n\n\n\n","category":"type"},{"location":"API/#DoseCalculations.PlaneSurface","page":"-","title":"DoseCalculations.PlaneSurface","text":"PlaneSurface\n\nA planar external surface at a constant distance from the source.\n\nIt assumes the external surface is a plane located at a distance of surf.source_surface_distance away from the source with normal from isocenter to source.\n\n\n\n\n\n","category":"type"},{"location":"API/#DoseCalculations.SurfaceBounds","page":"-","title":"DoseCalculations.SurfaceBounds","text":"SurfaceBounds{TSurface}\n\nRepresents a surface from a mesh.\n\n\n\n\n\n","category":"type"},{"location":"API/#Base.getindex-Tuple{Bixel, Int64}","page":"-","title":"Base.getindex","text":"Base.getindex(bixel::Bixel, i::Int)\n\nGet the centre position of the bixel.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.iterate-Tuple{DoseCalculations.AbstractTreatmentField}","page":"-","title":"Base.iterate","text":"iterate\n\nIteration of a treatment field, returning ControlPoint every time iterate is called.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.area-Tuple{Bixel}","page":"-","title":"DoseCalculations.area","text":"area(bixel::Bixel)\n\nReturn the area of the bixel.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.bixel_grid-NTuple{4, Any}","page":"-","title":"DoseCalculations.bixel_grid","text":"bixel_grid(x, y, Δx[, Δy])\n\nConstruct a grid of bixels.\n\nEach axis starts at the first element (e.g. x[1]), runs to the last element (x[end]), with uniform spacing (Δx). Same for y. Positions are \"snapped\" to the spacing value (see snapped_range for details).\n\nIf Δy not specified, assumes Δy = Δx.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.bixel_grid-Tuple{AbstractRange, AbstractRange}","page":"-","title":"DoseCalculations.bixel_grid","text":"bixel_grid(x::AbstractRange, y::AbstractRange)\n\nUses the start and end positions and step of each range to construct the bixel grid.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.bixel_grid-Tuple{DoseCalculations.AbstractMultiLeafCollimator, Jaws, Any}","page":"-","title":"DoseCalculations.bixel_grid","text":"bixel_grid(mlc::AbstractMultiLeafCollimator, jaws::Jaws, Δx)\n\nGrid that fits in an MLC and the jaws.\n\nBixel y widths are of the same width as the MLC leaf widths. Creates smaller widths in the case where the jaws are halfway within a leaf width. Bixel x widths are set by Δx.`\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.bixel_grid-Tuple{Jaws, Any, Any}","page":"-","title":"DoseCalculations.bixel_grid","text":"bixel_grid(jaws::Jaws, Δx[, Δy])\n\nUses the jaw positions to construct a bixel grid.\n\nIf Δy not specified, assumes Δy = Δx\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.bixels_from_bld","page":"-","title":"DoseCalculations.bixels_from_bld","text":"bixels_from_bld(args::AbstractBeamLimitingDevice...)\n\nCreate bixels corresponding to the provided beam limiting devices.\n\n\n\n\n\n","category":"function"},{"location":"API/#DoseCalculations.bixels_from_bld-Union{Tuple{Jaws{T}}, Tuple{T}} where T<:AbstractFloat","page":"-","title":"DoseCalculations.bixels_from_bld","text":"bixel_from_bld(jaws::Jaws)\n\nFrom Jaws.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.bixels_from_bld-Union{Tuple{T}, Tuple{DoseCalculations.AbstractMultiLeafCollimator, Jaws{T}}} where T<:AbstractFloat","page":"-","title":"DoseCalculations.bixels_from_bld","text":"bixels_from_bld(mlcx, mlc::MultiLeafCollimator, jaws::Jaws)\n\nFrom MultiLeafCollimator and Jaws.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.bld_to_fixed-Tuple{Any, Any, Any}","page":"-","title":"DoseCalculations.bld_to_fixed","text":"bld_to_fixed(ϕg, θb, SAD)\n\nConvert from IEC BLD to IEC fixed coordinates\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.bld_to_gantry-Union{Tuple{T}, Tuple{Any, T}} where T<:AbstractFloat","page":"-","title":"DoseCalculations.bld_to_gantry","text":"bld_to_gantry(θb, SAD)\n\nConvert from IEC BLD to IEC gantry coordinates\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.dose_fluence_matrix!-Tuple{SparseArrays.SparseMatrixCSC, Any, AbstractVector{var\"#s95\"} where var\"#s95\"<:Beamlet, DoseCalculations.AbstractExternalSurface, DoseCalculations.AbstractDoseAlgorithm}","page":"-","title":"DoseCalculations.dose_fluence_matrix!","text":"dose_fluence_matrix!(D, pos, beamlets, surf, calc)\n\nCompute a dose-fluence matrix from dose positions, beamlets, external surface and dose calculation algorithm.\n\nRequires the point_kernel! method to be defined for the given dose calculation algorithm (calc). point_kernel! computes the dose calculated from the set of bixels a given dose point. Stores result in D.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.dose_fluence_matrix-Tuple{Any, AbstractVector{var\"#s95\"} where var\"#s95\"<:Beamlet, DoseCalculations.AbstractExternalSurface, DoseCalculations.AbstractDoseAlgorithm}","page":"-","title":"DoseCalculations.dose_fluence_matrix","text":"dose_fluence_matrix(pos, beamlets, surf, calc)\n\nCompute a dose-fluence matrix from dose positions, beamlets, external surface and dose calculation algorithm.\n\nSee dose_fluence_matrix! for implementation.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.dose_kernel!-Tuple{SparseArrays.SparseMatrixCSC, Any, Any, Any, Any}","page":"-","title":"DoseCalculations.dose_kernel!","text":"dose_kernel!(rowval, nzval, pos::AbstractVector{T}, bixels, surf, calc)\n\nCompute the fluence kernel for a given position.\n\nDesigned to be used with a dose-fluence matrix of type SparseMatrixCSC. Stores the row value in rowval, and dose value in nzval.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.eclipse_to_SIK","page":"-","title":"DoseCalculations.eclipse_to_SIK","text":"eclipse_to_SIK(input_datadir)\n\nRead in Eclipse exported files, extracting Scaled Isoplane Kernel data\n\nRequires SinglePencilBeamKernel{depth} for multiple depths and MeasuredProfile files in input_datadir. Returns a dict with kernel and depth dose data.\n\n\n\n\n\n","category":"function"},{"location":"API/#DoseCalculations.eclipse_to_SPBK-Tuple{Any}","page":"-","title":"DoseCalculations.eclipse_to_SPBK","text":"eclipse_to_SPBK(input_datadir)\n\nRead in Eclipse exported files, extracting Single Pencil Beam Kernel data\n\nRequires SinglePencilBeamKernel{depth} and IntensityProf{depth} files in  input_datadir for multiple depths. Returns a dict with kernel and intensity profile data.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.extent-Tuple{CylinderBounds}","page":"-","title":"DoseCalculations.extent","text":"extent(bounds::CylinderBounds)\n\nFor a cylinder\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.extent-Tuple{DoseCalculations.AbstractBounds}","page":"-","title":"DoseCalculations.extent","text":"extent(bounds::AbstractBounds)\n\nReturns the bounding box of the bounds as two vectors: pmin, pmax\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.extent-Tuple{MeshBounds}","page":"-","title":"DoseCalculations.extent","text":"extent(bounds::MeshBounds)\n\nFor a mesh\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.extent-Tuple{SurfaceBounds}","page":"-","title":"DoseCalculations.extent","text":"extent(bounds::SurfaceBounds)\n\nFor a mesh\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.fixed_to_bld-Tuple{Any, Any, Any}","page":"-","title":"DoseCalculations.fixed_to_bld","text":"fixed_to_bld(ϕg, θb, SAD)\n\nConvert from IEC fixed to IEC BLD coordinates\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.fixed_to_gantry-Tuple{Any}","page":"-","title":"DoseCalculations.fixed_to_gantry","text":"fixed_to_gantry(ϕg)\n\nConvert from IEC fixed to IEC gantry coordinates\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.fluence-Tuple{AbstractArray{var\"#s38\", N} where {var\"#s38\"<:DoseCalculations.AbstractBixel, N}, AbstractArray{Int64, N} where N, Vararg{Any, N} where N}","page":"-","title":"DoseCalculations.fluence","text":"fluence(bixels::AbstractArray{<:AbstractBixel}, index::AbstractArray{Int}, args...)\n\nAllows precomputation of the location of the bixel in relation to the beam limiting device.\n\nIn the case of an MLC, the index is the leaf index that contains that bixel.\n\nRequires fluence(bixel::AbstractBixel, index::Int, args...) to be defined for the particular beam limiting device\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.fluence-Tuple{AbstractArray{var\"#s38\", N} where {var\"#s38\"<:DoseCalculations.AbstractBixel, N}, Vararg{Any, N} where N}","page":"-","title":"DoseCalculations.fluence","text":"fluence(bixels::AbstractArray{<:AbstractBixel}, bld::AbstractBeamLimitingDevice, args...)\n\nCompute the fluence on a collection of bixels.\n\nBroadcasts over the specific fluence(bixel, ...) method for the provided beam limiting device. e.g.: fluence(bixels, jaws), fluence(bixels, mlcx, mlc)\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.fluence-Tuple{Bixel, Jaws}","page":"-","title":"DoseCalculations.fluence","text":"fluence(bixel::Bixel, jaws::Jaws)\n\nFrom the Jaws.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.fluence-Tuple{DoseCalculations.AbstractBixel, DoseCalculations.AbstractBeamLimitingDevice, Vararg{Any, N} where N}","page":"-","title":"DoseCalculations.fluence","text":"fluence(bixel::AbstractBixel, bld::AbstractBeamLimitingDevice, args...)\n\nCompute the fluence of bixel from beam limiting device (e.g. an MLC or jaws).\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.fluence-Tuple{DoseCalculations.AbstractBixel, Int64, AbstractMatrix{T} where T, AbstractMatrix{T} where T}","page":"-","title":"DoseCalculations.fluence","text":"fluence(bixel::Bixel{T}, index::Int, mlcx1, mlcx2)\n\nFrom an MLC aperture sequence using a given leaf index.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.fluence-Tuple{DoseCalculations.AbstractBixel, Int64, AbstractMatrix{T} where T}","page":"-","title":"DoseCalculations.fluence","text":"fluence(bixel::Bixel, index::Int, mlcx)\n\nFrom an MLC aperture using a given leaf index.\n\nThis method assumes the bixel is entirely within the ith leaf track, and does not overlap with other leaves. Does not check whether these assumptions are true.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.fluence-Union{Tuple{T}, Tuple{Bixel{T}, MultiLeafCollimator, MultiLeafCollimator}} where T<:AbstractFloat","page":"-","title":"DoseCalculations.fluence","text":"fluence(bixel::Bixel{T}, mlc1::MultiLeafCollimator, mlc2::MultiLeafCollimator)\n\nFrom an MLC aperture sequence.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.fluence-Union{Tuple{T}, Tuple{Bixel{T}, MultiLeafCollimator}} where T<:AbstractFloat","page":"-","title":"DoseCalculations.fluence","text":"fluence(bixel::Bixel, mlc::MultiLeafCollimator)\n\nFrom an MLC aperture.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.fluence_from_moving_aperture-Union{Tuple{T}, Tuple{Bixel{T}, Any, Any}} where T<:AbstractFloat","page":"-","title":"DoseCalculations.fluence_from_moving_aperture","text":"fluence_from_moving_aperture(bixel::Bixel{T}, mlcx1, mlcx2)\n\nFrom MLC leaf positions which move from mlcx1 to mlcx2.\n\nComputes the time-weighted fluence as the MLC moves from position mlcx1 to mlcx2. Assumes the MLC leaves move in a straight line.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.fluence_from_rectangle-Tuple{Bixel, Any, Any}","page":"-","title":"DoseCalculations.fluence_from_rectangle","text":"fluence_from_rectangle(bixel::Bixel, xlim, ylim)\n\nCompute the fluence of a rectangle with edges at xlim and ylim on a bixel.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.fluence_grid_length-Tuple{DoseCalculations.AbstractDoseAlgorithm}","page":"-","title":"DoseCalculations.fluence_grid_length","text":"fluence_grid_length(calc::AbstractDoseAlgorithm)\n\nReturn number of bixels in the fluence grid.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.fluence_grid_size-Tuple{DoseCalculations.AbstractDoseAlgorithm}","page":"-","title":"DoseCalculations.fluence_grid_size","text":"fluence_grid_size(calc::AbstractDoseAlgorithm)\n\nReturn the size of the fluence grid.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.fluence_onesided-NTuple{4, Any}","page":"-","title":"DoseCalculations.fluence_onesided","text":"fluence_onesided(xs, xf, xL, xU)\n\nCompute fluence for 1 leaf position, assuming the other is infinitely far away\n\nComputes the fluence for a leaf trajectory from xs to xf, over a bixel from xL to xU. The aperture is considered open to the right of the leaf position (i.e. leaf on the B bank). Assumes the bixel is fully in the leaf track.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.gantry_to_bld-Union{Tuple{T}, Tuple{Any, T}} where T<:AbstractFloat","page":"-","title":"DoseCalculations.gantry_to_bld","text":"gantry_to_bld(θb, SAD)\n\nConvert from IEC gantry to IEC BLD coordinates\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.gantry_to_fixed-Tuple{Any}","page":"-","title":"DoseCalculations.gantry_to_fixed","text":"gantry_to_fixed(ϕg)\n\nConvert from IEC gantry to IEC fixed coordinates\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.getSSD-Tuple{ConstantSurface, Any, Any}","page":"-","title":"DoseCalculations.getSSD","text":"getSSD(calc::ConstantSurface, pos, src)\n\nWhen applied to a ConstantSurface, it returns a constant source surface distance, regardless of pos.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.getSSD-Tuple{DoseCalculations.AbstractExternalSurface, Any, Any}","page":"-","title":"DoseCalculations.getSSD","text":"getSSD(surf::AbstractExternalSurface, pos, src)\n\nGet the Source-Surface Distance (SSD) for position pos to the radiation source src.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.getSSD-Tuple{MeshSurface, Any, Any}","page":"-","title":"DoseCalculations.getSSD","text":"getSSD(surf::MeshSurface, pos, src)\n\nWhen applied to a MeshSurface, it returns the smallest distance to the mesh.\n\nReturns Inf if no intersection is found. \n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.getSSD-Tuple{PlaneSurface, Any, Any}","page":"-","title":"DoseCalculations.getSSD","text":"getSSD(surf::PlaneSurface, pos, src)\n\nWhen applied to a PlaneSurface, it returns the distance to the plane.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.get_dataset_line_numbers-Tuple{Any}","page":"-","title":"DoseCalculations.get_dataset_line_numbers","text":"getdatasetline_numbers(lines)\n\nGet the line numbers of each data section.\n\nLooks for the string \"Profiles\" in each line, then adds the line number to the list of dataset line numbers, which is returned. See readeclipseprofile_data\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.getdepth-Tuple{DoseCalculations.AbstractExternalSurface, Any, Any}","page":"-","title":"DoseCalculations.getdepth","text":"getdepth(surf::AbstractExternalSurface, pos, src)\n\nGet the depth of the position pos below the surface from the radiation source src.\n\nComputes the depth by subtracting \n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.getx-Tuple{DoseCalculations.AbstractDoseGrid}","page":"-","title":"DoseCalculations.getx","text":"getx(pos::AbstractDoseGrid)\n\nReturn the x axis of the grid\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.gety-Tuple{DoseCalculations.AbstractDoseGrid}","page":"-","title":"DoseCalculations.gety","text":"gety(pos::AbstractDoseGrid)\n\nReturn the y axis of the grid\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.getz-Tuple{DoseCalculations.AbstractDoseGrid}","page":"-","title":"DoseCalculations.getz","text":"getz(pos::AbstractDoseGrid)\n\nReturn the z axis of the grid\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.hypotenuse-Tuple{Any, Any}","page":"-","title":"DoseCalculations.hypotenuse","text":"hypotenuse(a, b)\n\nCompute the hypotenuse of triangle\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.integrate_kernel-Union{Tuple{T}, Tuple{ScaledIsoplaneKernel, Bixel{T}, T, T}} where T<:AbstractFloat","page":"-","title":"DoseCalculations.integrate_kernel","text":"integrate_kernel(calc::ScaledIsoplaneKernel, bixel::Bixel{T}, x_iso, y_iso) where T<:AbstractFloat\n\nIntegrate the kernel over bixel from position x_iso, y_iso.\n\nSubdivides the bixel for higher accuracy.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.interp-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractMatrix{T} where T, Any, Any}","page":"-","title":"DoseCalculations.interp","text":"interp(xg::AbstractVector, yg::AbstractVector, fg::AbstractMatrix, xi, yi)\n\nBilinear interpolation at position xi,yi, on grid xg-yg with values fg\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.interp-Tuple{Any, Any, Any}","page":"-","title":"DoseCalculations.interp","text":"interp(f1, f2, α)\n\nInterpolate using given values f1 and f2 and the scaled distance from them α\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.interp-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Any}} where T<:Real","page":"-","title":"DoseCalculations.interp","text":"interp(xg::AbstractVector{T}, fg::AbstractVector{T}, xi) where T<:Real\n\nInterpolate xi within uniform grid positions xg and grid values fg\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.intersect_mesh-Union{Tuple{T}, Tuple{Dim}, Tuple{Meshes.Geometry, Meshes.Domain{Dim, T}}} where {Dim, T}","page":"-","title":"DoseCalculations.intersect_mesh","text":"intersect_mesh(s, mesh)\n\nFind the intersection points of the line and the mesh.\n\nReturns a list of intersection points, and an empty list if none present.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.intersect_mesh_multi_threaded-Union{Tuple{T}, Tuple{Dim}, Tuple{Meshes.Geometry, Meshes.Domain{Dim, T}}} where {Dim, T}","page":"-","title":"DoseCalculations.intersect_mesh_multi_threaded","text":"intersect_mesh_multi_threaded(s, mesh)\n\nMulti-threaded version of intersect_mesh.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.intersect_mesh_single_threaded-Union{Tuple{T}, Tuple{Dim}, Tuple{Meshes.Geometry, Meshes.Domain{Dim, T}}} where {Dim, T}","page":"-","title":"DoseCalculations.intersect_mesh_single_threaded","text":"intersect_mesh_single_threaded(s, mesh)\n\nSingle-threaded version of intersect_mesh.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.kernel-Tuple{ScaledIsoplaneKernel, Any}","page":"-","title":"DoseCalculations.kernel","text":"kernel(calc::ScaledIsoplaneKernel, r)\n\nGet the kernel at radius r.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.kernel_size-Tuple{ScaledIsoplaneKernel, StaticArraysCore.SVector{3, T} where T, AbstractVector{var\"#s4\"} where var\"#s4\"<:DoseCalculations.AbstractBixel, Any}","page":"-","title":"DoseCalculations.kernel_size","text":"kernel_size(calc::ScaledIsoplaneKernel, pos, bixels, gantry)\n\nCompute the number of bixels with the max. radius of a given position.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.leaf_trajectory-Tuple{Any, Any, Any}","page":"-","title":"DoseCalculations.leaf_trajectory","text":"leaf_trajectory(x, x1, x2)\n\nCompute the height of position x between (x1, 0) and (x2, 1)\n\nUsed in intersection_area.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.load-Tuple{Type{DoseGridMasked}, HDF5.H5DataStore}","page":"-","title":"DoseCalculations.load","text":"load(::Type{DoseGridMasked}, file::HDF5.H5DataStore)\n\nLoad DoseGridMasked data from an HDF5 file/group\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.load-Tuple{Type{DoseGrid}, HDF5.H5DataStore}","page":"-","title":"DoseCalculations.load","text":"load(::Type{DoseGrid}, file::HDF5.H5DataStore)\n\nLoad DoseGrid data from an HDF5 file/group\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.load-Tuple{Type{Jaws}, HDF5.H5DataStore}","page":"-","title":"DoseCalculations.load","text":"load(::Type{Jaws}, file::HDF5.H5DataStore)\n\nLoad Jaws data from an HDF5 file/group\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.load-Tuple{Type{VMATField}, HDF5.H5DataStore}","page":"-","title":"DoseCalculations.load","text":"load(::Type{VMATField}, file::HDF5.H5DataStore)\n\nLoad VMATField data from an HDF5 file/group\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.load_beam-Tuple{Any, Any}","page":"-","title":"DoseCalculations.load_beam","text":"load_beam(beam, total_meterset)\n\nLoad a beam from a control point sequence in a DICOM RP file.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.load_dicom-Tuple{Any}","page":"-","title":"DoseCalculations.load_dicom","text":"load_dicom(filename)\n\nLoad a DICOM RP file into a Vector{TreatmentField}.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.load_kernel_data-Tuple{Any}","page":"-","title":"DoseCalculations.load_kernel_data","text":"load_kernel_data(filename)\n\nLoad a kernel data file in Eclipse format.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.load_ref_dose-Tuple{Any}","page":"-","title":"DoseCalculations.load_ref_dose","text":"load_ref_dose(beam)\n\nLoad a reference dose, used for calculating the meterset in a control point sequence\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.load_structure_from_ply-Tuple{Any}","page":"-","title":"DoseCalculations.load_structure_from_ply","text":"load_structure_from_ply(filename)\n\nLoad a .ply file into a mesh\n\nUses MeshIO to load the mesh from the file. Unfortunately, MeshIO loads into GeometryBasics.Mesh, not Meshes.SimpleMesh. The rest of the code converts the mesh into a Meshes.SimpleMesh. From https://github.com/JuliaIO/MeshIO.jl/issues/67#issuecomment-913353708\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.locate-Tuple{Any, Any, Any}","page":"-","title":"DoseCalculations.locate","text":"locate(x::T, start::T, step::T) where T<:AbstractFloat\n\nLocate the grid index for position xi\n\nSpecify the grid starting position (start) and grid spacing (step).\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.locate-Tuple{DoseCalculations.AbstractMultiLeafCollimator, Any}","page":"-","title":"DoseCalculations.locate","text":"locate(mlc::AbstractMultiLeafCollimator, x::Number)\n\nLocate the track index i which contains the position x\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.locate-Union{Tuple{T}, Tuple{AbstractRange{T}, T}} where T<:Real","page":"-","title":"DoseCalculations.locate","text":"locate(xg::AbstractRange{T}, xi::T) where T<:Real\n\nWhen a range is provided, uniform spacing can be assumed.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.locate-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T<:Real","page":"-","title":"DoseCalculations.locate","text":"locate(xg::AbstractVector{T}, xi::T) where T<:Real\n\nLocates the grid index for position x within a grid xg. Does not limit out of bounds indices.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.minmax-Tuple{Any, Any, Any}","page":"-","title":"DoseCalculations.minmax","text":"minmax(x, l, u)\n\nReturn x if l<=x<=u, l if x<l or u if u<x\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.norm_depth_dose-Tuple{ScaledIsoplaneKernel, Any}","page":"-","title":"DoseCalculations.norm_depth_dose","text":"norm_depth_dose(calc::ScaledIsoplaneKernel, d)\n\nGet the normalised depth dose at depth d.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.overlap-NTuple{4, Number}","page":"-","title":"DoseCalculations.overlap","text":"overlap(x, Δx, xB, xA)\n\nCompute the overlapping length of a bixel spanning x-w/2->x+w/2 and the length between xL and xU, normalised to the length of the bixel. If the Bixel fully within range (xL<=x-w/2 && x+w/2<=xU), return 1. If the bixel is fully outside the range (xU<=x-w/2 || x+w/2<=xL), return 0.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.parse_value-Tuple{Any}","page":"-","title":"DoseCalculations.parse_value","text":"parse_value(string_value)\n\nTries to parse a string, returning string if parsing failed\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.patient_to_fixed-Tuple{Any}","page":"-","title":"DoseCalculations.patient_to_fixed","text":"patient_to_fixed(isocenter)\n\nConvert from the patient-based coordinate system to IEC Fixed.\n\nIsocenter is in the patient-based coordinate system, as specified in the DICOM RP file.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.point_kernel!-Union{Tuple{T}, Tuple{Any, Any, AbstractVector{T}, Any, Any, Any, Any}} where T<:AbstractFloat","page":"-","title":"DoseCalculations.point_kernel!","text":"point_kernel!(rowval, nzval, pos::AbstractVector{T}, bixels, surf, calc)\n\nCompute the fluence kernel for a given position.\n\nDesigned to be used with a dose-fluence matrix of type SparseMatrixCSC. Stores the row value in rowval, and dose value in nzval.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.position-Tuple{Bixel, Int64}","page":"-","title":"DoseCalculations.position","text":"position(bixel::Bixel, i::Int)\n\nGet the ith coordinate of the position.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.position-Tuple{Bixel}","page":"-","title":"DoseCalculations.position","text":"position(bixel::Bixel)\n\nGet the position of the bixel.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.read_attr-Tuple{Any}","page":"-","title":"DoseCalculations.read_attr","text":"read_attr(line)\n\nRead attribute name and value\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.read_attributes-Tuple{Any}","page":"-","title":"DoseCalculations.read_attributes","text":"read_attributes(filename)\n\nRead attributes from Eclipsed exported measured data file. See readeclipsedepthdose and readeclipse_profile.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.read_data_line-Tuple{Any}","page":"-","title":"DoseCalculations.read_data_line","text":"read_data_line(line; delim=',')\n\nRead a line of data of the form:     x1, x2, ... where ',' is the delimiter\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.read_dataset-Tuple{Any}","page":"-","title":"DoseCalculations.read_dataset","text":"read_dataset(lines)\n\nRead each line in lines and extract the header row, row index and data.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.read_eclipse_datafile","page":"-","title":"DoseCalculations.read_eclipse_datafile","text":"read_eclipse_datafile(filename::String, truncate=true)\n\nRead an Eclipse data from file.\n\nReads Eclipse data from files such as SinglePencilBeamKernel, IntensityProf and EnvelopeProfile files. The files are generally of the form:\n\n```\n%attr1_name: attr1_value\n%attr2_name: attr2_value\n    ...\n<x1 y1>\n<x2 y2>\n    ...\n<xn yn>\n```\n\nArgs:\n\nfilename: File path\ntruncate: Whether to remove zeros, default true (see truncate_zeros)\n\n\n\n\n\n","category":"function"},{"location":"API/#DoseCalculations.read_eclipse_depth_dose_data-Tuple{Any}","page":"-","title":"DoseCalculations.read_eclipse_depth_dose_data","text":"read_eclipse_depth_dose_data(filename)\n\nRead an Eclipse exported depth dose file.\n\nThis file is of the form:\n\n```\n%attr1_name: attr1_value\n%attr2_name: attr2_value\n    ...\n    ,    col1,    col2, ...,    colm\nrow1,     x11,     x12, ...,    col1m\nrow2,     x21,     x22, ...,    col2m\n    ...\nrown, ...\n```\n\nReturns a dictionary with attributes, the column header (as given by column legend), the row index (row legend), and a matrix containing the data.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.read_eclipse_profile_data-Tuple{Any}","page":"-","title":"DoseCalculations.read_eclipse_profile_data","text":"read_eclipse_profile_data(filename)\n\nRead an Eclipse exported profile file.\n\nSimilar to readeclipsedepthdosedata, except profile files can have multiple datasets at different depths. This file is of the form:\n\n```\n%attr1_name: attr1_value\n%attr2_name: attr2_value\n    ⁞\nProfile at d1\n    ,    col1,    col2, ...,    colm\nrow1,     x11,     x12, ...,    col1m\n    ⁞\nrown, ...\nProfile at d2\n    ,    col1,    col2, ...,    colm\nrow1,     x11,     x12, ...,    col1m\n    ⁞\nrown, ...\n    ⁞\n```\n\nReturns a dictionary with attributes and profile data. Profile data is stored in a vector under data[\"Profiles\"].\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.reconstruct_dose-NTuple{4, Any}","page":"-","title":"DoseCalculations.reconstruct_dose","text":"reconstruct_dose(pos, surf, plan, calc; Δx=1., show_progess=true)\n\nReconstruct the dose.\n\nRequires dose positions (pos), an external surface (surf), a set of beams (plan), and the dose calculation algorithm (calc). Optional arguments include:\n\nΔx: Size of each bixel in the fluence grid (defaults to 1.)\nΔMU: Meterset increments (defaults to 2.)\nshow_progess: Whether to display the progress (defaults to true)\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.resample-Union{Tuple{T}, Tuple{Any, T}} where T<:Number","page":"-","title":"DoseCalculations.resample","text":"resample(field, Δη::T; by=:MU)\n\nResample at uniform steps Δη, from start to finish.\n\nSee resample(field, ηₛ::AbstractVector{T}; by=:MU) for details.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.resample-Union{Tuple{T}, Tuple{DoseCalculations.AbstractTreatmentField, AbstractVector{T}}} where T<:AbstractFloat","page":"-","title":"DoseCalculations.resample","text":"resample(field, ηₛ::AbstractVector{T}; by=:time)\n\nResample a treatment field onto new times or meterset values.\n\nCan resample either by time (by=:time) or MU (by=:MU, default).\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.save-Tuple{HDF5.H5DataStore, DoseGridMasked}","page":"-","title":"DoseCalculations.save","text":"save(file::HDF5.H5DataStore, pos::DoseGridMasked)\n\nStore DoseGridMasked data to an HDF5 file/group\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.save-Tuple{HDF5.H5DataStore, DoseGrid}","page":"-","title":"DoseCalculations.save","text":"save(file::HDF5.H5DataStore, pos::DoseGrid)\n\nStore DoseGrid data to an HDF5 file/group\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.save-Tuple{HDF5.H5DataStore, Jaws}","page":"-","title":"DoseCalculations.save","text":"save(file::HDF5.H5DataStore, jaws::Jaws)\n\nStore Jaws data to an HDF5 file/group\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.save-Tuple{HDF5.H5DataStore, VMATField}","page":"-","title":"DoseCalculations.save","text":"save(file::HDF5.H5DataStore, field::VMATField)\n\nStore VMATField data to an HDF5 file/group\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.scale_to_cell-Tuple{Any, Any, Any}","page":"-","title":"DoseCalculations.scale_to_cell","text":"scale_to_cell(x1, x2, xi)\n\nScale the position xi within the positions x1 and x2.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.scale_to_isoplane-Tuple{Any, Any}","page":"-","title":"DoseCalculations.scale_to_isoplane","text":"scale_to_isoplane(pᵢ, z_plane)\n\nScale the position pᵢ to the plane at distance z_plane.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.snapped_range-Tuple{Any, Any, Any}","page":"-","title":"DoseCalculations.snapped_range","text":"snapped_range(x1, x2, Δ)\n\nCreate a range from x1 to x2 which is \"snapped\" to the step Δ.\n\nPositions are \"snapped\" to the step value (e.g. a starting position of x[1]-0.2Δx snaps to x[1]-Δx). The new range always includes the start and end points of the original range\n\nExamples:\n\n0.1:1.:9.4 -> 0:1.:10.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.split_lines_into_datasets-Tuple{Any, Any}","page":"-","title":"DoseCalculations.split_lines_into_datasets","text":"split_lines_into_datasets(lines, sections)\n\nSplit the lines into each dataset. See readeclipseprofile_data\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.subdivide-Tuple{Any, Any, Any}","page":"-","title":"DoseCalculations.subdivide","text":"subdivide(x, Δx, δxmax)\n\nSubdivide at position x with width Δx with a max subvision width of δxmax\n\nReturns the starting position, the subdivision width and the number of subdivisions. Allows for use in a loop, where the center of subdivision i is at:     x0 + i*δx from 0:nx-1\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.subdivide-Tuple{Bixel, Integer, Integer}","page":"-","title":"DoseCalculations.subdivide","text":"subdivide(bixel::Bixel, nx::Integer, ny::Integer)\n\nSubdivide a bixel by specifing the number of partitions nx and ny.\n\nReturns a grid of bixels.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.subdivide-Union{Tuple{T}, Tuple{Bixel{T}, T, T}} where T<:AbstractFloat","page":"-","title":"DoseCalculations.subdivide","text":"subdivide(bixel::Bixel{T}, δx::T, δy::T)\n\nSubdivide by specifing widths δx and δy\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.transform!-Tuple{Any, Any}","page":"-","title":"DoseCalculations.transform!","text":"transform!(mesh::SimpleMesh, trans)\n\nApply general transformation trans to mesh, modifying the original mesh.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.transform-Tuple{Meshes.SimpleMesh, Any}","page":"-","title":"DoseCalculations.transform","text":"transform(mesh::SimpleMesh, trans)\n\nApply general transformation trans to mesh`.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.truncate_zeros-Tuple{Any, Any}","page":"-","title":"DoseCalculations.truncate_zeros","text":"truncate_zeros(x, y)\n\nRemoves every element after first zero in y and corresponding x\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.vtk_create_cell-Tuple{Any}","page":"-","title":"DoseCalculations.vtk_create_cell","text":"vtk_create_cell(cell)\n\nReturn the VTK cell type for a list of cell indices.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.width-Tuple{Bixel, Int64}","page":"-","title":"DoseCalculations.width","text":"width(bixel::Bixel, i::Int)\n\nReturn the width of the bixel along axis i.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.width-Tuple{Bixel}","page":"-","title":"DoseCalculations.width","text":"width(bixel::Bixel)\n\nReturn the width of the bixel.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.within-Tuple{CylinderBounds, Any}","page":"-","title":"DoseCalculations.within","text":"within(bounds::CylinderBounds, p)\n\nWhether p is within the cylinder\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.within-Tuple{DoseCalculations.AbstractBounds, Any}","page":"-","title":"DoseCalculations.within","text":"within(bounds::AbstractBounds, p)\n\nReturns true if the point p is within bounds\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.within-Tuple{MeshBounds, Any}","page":"-","title":"DoseCalculations.within","text":"within(bounds::MeshBounds, p)\n\nWhether p is within the mesh\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.within-Tuple{SurfaceBounds, Any}","page":"-","title":"DoseCalculations.within","text":"within(bounds::SurfaceBounds, p)\n\nWhether p is within the mesh\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.write_nrrd-Tuple{String, DoseGrid, AbstractArray}","page":"-","title":"DoseCalculations.write_nrrd","text":"write_nrrd(filename::String, pos::DoseGrid, data::AbstractArray)\n\nWrite DoseGrid to the NRRD data format.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.write_nrrd-Tuple{String, DoseGridMasked, AbstractArray}","page":"-","title":"DoseCalculations.write_nrrd","text":"write_nrrd(filename::String, pos::DoseGridMasked, data::AbstractArray; fillvalue=NaN)\n\nWrite DoseGridMasked to the NRRD data format.\n\nMasked points in DoseGridMasked are filled with fillvalue, defaults to NaN.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.write_vtk-Tuple{Any, Meshes.SimpleMesh}","page":"-","title":"DoseCalculations.write_vtk","text":"write_vtk(filename, mesh::SimpleMesh)\n\nSave a SimpleMesh to a VTK (.vtu) file.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.write_vtk-Tuple{String, DoseGrid, Vararg{Any, N} where N}","page":"-","title":"DoseCalculations.write_vtk","text":"write_vtk(filename::String, pos::DoseGrid, data::Union{Vararg, Dict})\n\nSave DoseGrid to the VTK Image data (vti) format.\n\n\n\n\n\n","category":"method"},{"location":"API/#DoseCalculations.write_vtk-Tuple{String, DoseGridMasked, Vararg{Any, N} where N}","page":"-","title":"DoseCalculations.write_vtk","text":"write_vtk(filename::String, pos::DoseGridMasked, data::Union{Vararg, Dict})\n\nSave DoseGridMasked to the VTK Unstructured Grid (vtu) format.\n\n\n\n\n\n","category":"method"}]
}
