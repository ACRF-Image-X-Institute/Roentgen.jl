var documenterSearchIndex = {"docs":
[{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"using Roentgen","category":"page"},{"location":"Fluence/#Generating-Fluence-Maps","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"","category":"section"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"In order to compute dose, an idealised fluence distribution needs to be created.","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"This is usually done by generating fluence maps on a set of bixels from beam-limiting devices, such as the jaws or MLC.","category":"page"},{"location":"Fluence/#Beam-Limiting-Devices","page":"Generating Fluence Maps","title":"Beam-Limiting Devices","text":"","category":"section"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"Beam-limiting devices contain information on the position and shape of the aperture. These typically relate to physical devices on the treatment machine, such as a Multi-Leaf Collimator. Each have specialised methods by which they interact with bixels and assign an amount of fluence going through the bixel.","category":"page"},{"location":"Fluence/#Jaws","page":"Generating Fluence Maps","title":"Jaws","text":"","category":"section"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"Jaws are rectangular field shapes, which are simply constructed by specifying the position of the left, right, top and bottom jaws, or a fieldsize:","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"jaws = Jaws(-10., 10., -15., 15.)\njaws = Jaws(100.)","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"They have methods for accessing the positions, and the area,","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"getx(jaws)\ngety(jaws)\ngetarea(jaws)","category":"page"},{"location":"Fluence/#Multi-Leaf-Collimator","page":"Generating Fluence Maps","title":"Multi-Leaf Collimator","text":"","category":"section"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"Multi-Leac Collimator (MLC) contain the position of the leaves (in the x direction), and the position of the leaf edges (the y direction).","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"They are constructed by specifying leaf positions in a 2xn matrix and leaf edges in an n+1 length vector,","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"mlcx = [-10. -12. -23.\n         10.   4. -10.];\nmlcy = -5.:5.:10;\nmlc = MultiLeafCollimator(mlcx, mlcy)","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"They can also be constructed by just specifying the edges, which sets the leaf positions to zero,","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"MultiLeafCollimator(mlcy)","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"Indexing and iterating through the MLC will produce a subset of the MLC, either returning Jaws or another MultiLeafCollimator,","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"mlc[1]\nmlc[2:3]\n@view mlc[1:2]","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"Leaf positions can be accessed using the getpositions,","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"getpositions(mlc)\ngetpositions(mlc, 1)","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"Edge positions can be accessed using getedges,","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"getedges(mlc)\ngetedges(mlc, 1)\ngetedges(mlc, 1:2)","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"Leaf positions can be set with setpositions! and closed with closeleaves!","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"closeleaves!(mlc)\nmlc[1] = -5., 25\nmlc\nmlcx = [-10. -12. -23.\n         10.   4. -10.];\nsetpositions!(mlc, mlcx)","category":"page"},{"location":"Fluence/#Bixels","page":"Generating Fluence Maps","title":"Bixels","text":"","category":"section"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"Bixels are 2D elements denoting a rectangular section of the isoplane. Their position and width is in the IEC BLD coordinate system, scaled to the isoplane.","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"Bixels are constructed by specifing their position and width,","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"bixel = Bixel(0., 0., 1., 1.)","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"A collection of bixels is used to build a fluence map. Most functions will take a list of bixels (AbstractVector{Bixel}). These can either be constructed using the Bixel constructor, or using one of the following bixel methods.","category":"page"},{"location":"Fluence/#Bixel-Grids","page":"Generating Fluence Maps","title":"Bixel Grids","text":"","category":"section"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"Bixel grids store bixels in a rectilinear grid, and behave as Matrix{Bixel}. They can be constructed by supplying a vector or range of bixel edge positions,","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"bixels = BixelGrid(-10.:5.:10, -10.:5.:10.)","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"Bixel grids can also be constructed using the information from beam-limiting devices,","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"jaws = Jaws([-5., 5.], [-10., 10.])\nbixels = BixelGrid(jaws, 5., 5.)","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"They behave like matrices: they can be indexed (both linear and Cartesian indexing), and iterate through each bixel,","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"bixels[3]\nbixels[1, 2]","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"They also have specialised methods for accessing grid axes,","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"getaxes(bixels)\ngetaxes(bixels, 1)","category":"page"},{"location":"Fluence/#Bixels-from-Beam-Limiting-Devices","page":"Generating Fluence Maps","title":"Bixels from Beam-Limiting Devices","text":"","category":"section"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"In addition to the creation of bixel grids from beam-limiting devices, bixels_from_bld creates a vector of bixels that span the open aperture of the beam-limiting device, e.g.","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"bixels = bixels_from_bld(mlc, jaws)","category":"page"},{"location":"Fluence/#Fluence","page":"Generating Fluence Maps","title":"Fluence","text":"","category":"section"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"Fluence is computed using the fluence method with bixel and beam-limiting devices as inputs,","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"fluence(bixel, jaws)","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"These are available for all beam-limiting devices.","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"Fluence maps similarly are generated fluence and fluence! methods,","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"Ψ = fluence(bixels, mlc)\nfluence!(Ψ, bixels, mlc)","category":"page"},{"location":"Fluence/","page":"Generating Fluence Maps","title":"Generating Fluence Maps","text":"They can also be computed in-place with fluence!, avoiding memory allocation.","category":"page"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"using Roentgen","category":"page"},{"location":"DoseFluenceMatrix/#Dose-Fluence-Matrix","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"","category":"section"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"Dose-fluence matrices are precomputed doses for each beamlet used in the treatment. In dose calculations, it is typical for a broad radiation beam to be split up into a number of beamlets. These beamlets can then be \"turned on/off\" depending on whether that beamlet is obscured by a beam-limiting device.","category":"page"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"Hence, dose computed through use of a dose-fluence matrix requires four steps:","category":"page"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"Select the beamlets that are to be used in the treatment\nCompute the dose at n dose positions for m beamlets, and store it in a nxm matrix, D.\nCompute the fluence and meterset increment for each beamlet, and store in an m length vector, w.\nCompute the final dose by multiplying the dose-fluence matrix D by w: mathrmdose=Dw","category":"page"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"An example can be found in the Dose From Aperture notebook.","category":"page"},{"location":"DoseFluenceMatrix/#Beamlets","page":"Dose-Fluence Matrix","title":"Beamlets","text":"","category":"section"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"Beamlets have three features:","category":"page"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"An origin, typically where the radiation originates\nA direction, pointing away from the source\nWidths in directions perpendicular to the beamlet direct, usually scaled to the isoplane","category":"page"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"Beamlets can be be constructed by combining a Bixel and GantryPosition,","category":"page"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"bixel = Bixel(0., 0., 1., 1.)\ngantry = GantryPosition(0., 0., 1000.)\nbeamlet = Beamlet(bixel, gantry)","category":"page"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"This will create a square beamlet of width 1 mm, origin of [0., 0., 1000.], and direction [0., 0., -1.].","category":"page"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"Collection of beamlets are created using Julia's broadcast mechanism,","category":"page"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"bixels = BixelGrid(-5.:5.:5., -5.:5.:5.);\nbeamlets = Beamlet.(bixels, (gantry,))","category":"page"},{"location":"DoseFluenceMatrix/#Creating-Dose-Fluence-Matrices","page":"Dose-Fluence Matrix","title":"Creating Dose-Fluence Matrices","text":"","category":"section"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"Dose-fluence matrices are computed using the dose_fluence_matrix and dose_fluence_matrix! functions. These take a [dose volume}(@ref DoseVolumes), vector of beamlets (Beamlets) and dose calculation algorithm and compute the corresponding dose for each position in the volume,","category":"page"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"dose_fluence_matrix(T, vol, beamlets, calc; maxradius=100)","category":"page"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"By default, dose is not calculated for every element in the dose-fluence matrix. Dose points that are further away than maxradius (scaled to the isoplane) from the beamlet axis are not computed and assumed to be zero. This speeds up computation (and memory if sparse matrices are used). maxradius is set to 100 mm by default.","category":"page"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"dose_fluence_matrix creates allocates a new matrix, then computes the matrix values. The first argument requires the matrix type:","category":"page"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"Type Sparse GPU\nMatrix ✖ ✖\nSparseMatrixCSC ✔ ✖\nCuArray ✖ ✔","category":"page"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"Each choice has benefits and downsides. Using a dense Matrix might be the fastest and easiest to manage memory wise, but comes with potentially large memory requirements depending on the number of positions or beamlets. A sparse SparseMatrixCSC only stores non-zero elements of the matrix, and is therefore less memory intensive and may be faster depending on the size of and number of non-zeros in the matrix.","category":"page"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"warning: Warning\nGPU support is still experimental","category":"page"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"If a GPU is available, using CuArray will move the computation to the GPU and speed up the computation significantly. However, all input arguments must be moved to GPU memory, and some types of external surface are not supported on the GPU. See the Computing on the GPU example for details.","category":"page"},{"location":"DoseFluenceMatrix/#Performance-Intensive-Usage","page":"Dose-Fluence Matrix","title":"Performance Intensive Usage","text":"","category":"section"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"dose_fluence_matrix! should be used for more perfomance intensive applications, modifying the supplied matrix. In this case, the method will specialise depending on the type of the matrix,","category":"page"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"dose_fluence_matrix!(D, vol, beamlets, calc; maxradius=100)","category":"page"},{"location":"DoseFluenceMatrix/","page":"Dose-Fluence Matrix","title":"Dose-Fluence Matrix","text":"where D is the matrix.","category":"page"},{"location":"ExternalSurfaces/#External-Surfaces","page":"External Surfaces","title":"External Surfaces","text":"","category":"section"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"This library provides an interface to provide an external surface, which is used for source-surface distance (SSD) and depth calculations. Physically, the external surface denotes the boundary between air and the dose absorbing medium (e.g. the patient's skin or the surface of a phantom).","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"All external surfaces exposes two methods,","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"getSSD(surf, p, s): Returns the source-surface distance (SSD)\ngetdepth(surf, p, s): Returns the depth below the source-surface intersection","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"(Image: external_surface)","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"Both of these methods take an external surface (surf) and two position vectors, p and s. The position p is usually a location where dose is computed, and is a three-element vector. The position s is the position of the radiation source. Both positions are in the IEC Fixed coordinate system.","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"For example:","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"using Roentgen","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"surf = PlaneSurface(800.)\ns = [0., 0., 1000.]\np = [10., 20., 0.]\ngetSSD(surf, p, s)\ngetdepth(surf, p, s)","category":"page"},{"location":"ExternalSurfaces/#Types-of-External-Surface","page":"External Surfaces","title":"Types of External Surface","text":"","category":"section"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"To enable source-surface and depth computations, a number of concrete external surface types are defined. These store the surface information and provides the implementation of the getSSD and getdepth methods.","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"The choice of which type to use is largely dependent on your use case, whether you prefer  accuracy or speed.","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"Where accuracy is preferred over speed, Cylindrical Surface and Mesh Surface provide accurate source-surface and depth computations. Generally Cylindrical Surface is recommended over Mesh Surface.\nIn the case of beam commissioning or water-tank doses, Plane Surface is recommended.\nWhere speed is preferred, consider using Linear Surface\nFor specialised setups, it may be best to implement a custom external surface.","category":"page"},{"location":"ExternalSurfaces/#Plane-Surface","page":"External Surfaces","title":"Plane Surface","text":"","category":"section"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"A simple plane surface (PlaneSurface), positioned at a constant source-surface distance along the central beam axis with normal pointed towards the source. Construct by supplying a source-surface distance, e.g. 800mm:","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"surf = PlaneSurface(800.)","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"This surface is best used in two scenarios:","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"The external surface is a box and the source does not rotate. This setup is common in beam commissioning, where dose in computed in a water tank.\nAccuracy is less important than speed: this method computes source-surface distance or depth much faster than other methods.","category":"page"},{"location":"ExternalSurfaces/#Cylindrical-Surface","page":"External Surfaces","title":"Cylindrical Surface","text":"","category":"section"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"The CylindricalSurface stores the external surface on a cylindrical-polar grid. This coordinate system is aligned to the IEC Fixed coordinate system, defined by the following convention:","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"rho: radial distance from the IEC fixed y axis.\ny: axial position along the IEC fixed y axis.\nϕ: azimuthal position, equivalent to the gantry angle.","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"This a faster way of computing mesh intersections, recommended over using a Mesh Surface.","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"CylindricalSurface can be constructed by directly supplying the cylindrical-polar surface: y, ϕ and rho,","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"ϕ = 0:deg2rad(2.):2π\ny = -100.:2.:100.\nrho = @. (80+20*sin(ϕ))*(1-(y'/200)^2)\nsurf = CylindricalSurface(ϕ, y, rho)","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"CylindricalSurface can also be constructed using a mesh,","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"mesh = load_structure_from_ply(\"path/to/stl-or-ply\")\nsurf = CylindricalSurface(mesh, Δy)","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"In this example, the bounds in the y direction will encompass the whole mesh with spacing of Δy. The axial y axis can be provided instead of a spacing, allowing finer control of the extent of the surface. See CylindricalSurface for further details.","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"note: Note\nCylindricalSurface assumes the mesh can be well defined in a cylindrical-polar coordinate system. It is up to the user to ensure this, which may require rotating the mesh such. See Coordinate Transformations for more information on rotating meshes.","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"CylindricalSurface can be written to the VTK file format for visualisation:","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"write_vtk(\"surface\", surf)","category":"page"},{"location":"ExternalSurfaces/#Mesh-Surface","page":"External Surfaces","title":"Mesh Surface","text":"","category":"section"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"The MeshSurface is defined by a 3D mesh provided by the user.","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"This surface can be constructed by supplying a mesh:","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"mesh = load_structure_from_ply(\"path/to/stl-or-ply\")\nsurf = MeshSurface(mesh)","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"warning: Warning\nThis is considered a slow method - the ray-tracing method is inefficient as it iterates through every face in the mesh (see Roentgen.intersect_mesh) - and should only be used if the mesh is small, computation time is not important, or a better surface is not available. A better alternative would be to create an Cylindrical Surface.","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"MeshSurface can be written to the VTK file format for visualisation:","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"write_vtk(\"surface\", surf)","category":"page"},{"location":"ExternalSurfaces/#Linear-Surface","page":"External Surfaces","title":"Linear Surface","text":"","category":"section"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"LinearSurface is a linear approximation to a general surface. It computes a set of planes normal to a general surface at the intersection of the line between the iso-center and source positions.","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"It is recommended to construct from a mesh,","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"mesh = load_structure_from_ply(\"path/to/stl-or-ply\")\nsurf = LinearSurface(mesh)","category":"page"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"where it computes the plane position and normal for each degree of gantry angle.  See LinearSurface for further details.","category":"page"},{"location":"ExternalSurfaces/#Constant-Surface","page":"External Surfaces","title":"Constant Surface","text":"","category":"section"},{"location":"ExternalSurfaces/","page":"External Surfaces","title":"External Surfaces","text":"A constant surface (ConstantSurface) returns constant source-surface distance. Depth is computed as the distance from point to source minus the source-surface distance. Generally only used for testing purposes.","category":"page"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"using Roentgen","category":"page"},{"location":"DosePositions/#Dose-Positions","page":"Dose Positions","title":"Dose Positions","text":"","category":"section"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"Dose positions are positions in the patient volume where dose is computed. While this could span the whole patient volume, for some applications a smaller dose volume is preferred which target various regions or structures in the body.","category":"page"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"A number of dose position types are provided. There are generally two ways of creating dose positions: through the default constructor, or using a bounding object.","category":"page"},{"location":"DosePositions/#Dose-Grids","page":"Dose Positions","title":"Dose Grids","text":"","category":"section"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"Dose grids are a subtype of dose positions where each position is located on a Cartesian grid. Each axis need not be uniform, they can take any vector of positions.  These are useful as they reduce memory usage, and allow for easy export to visualisation software.","category":"page"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"DoseGrid is a simple Cartesian grid where dose is computed on every point in the box.","category":"page"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"They are constructed by supplying grid axes:","category":"page"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"axes = (-10.:5.:10, -10.:5.:10, -10.:5.:10)\npos = DoseGrid(axes);","category":"page"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"When using a bounding object, the dose grid dimensions are set to encompass the whole bounding object. For example, a dose grid bounded by a cylinder will produce the following:","category":"page"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"pos = DoseGrid(5., CylinderBounds(10., 10.));\ngetaxes(pos)","category":"page"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"It supports both linear and Cartesian indexing:","category":"page"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"pos[1]\npos[1, 2, 3]","category":"page"},{"location":"DosePositions/#Masked-Dose-Grid","page":"Dose Positions","title":"Masked Dose Grid","text":"","category":"section"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"Masked dose grids are Cartesian grids where points can be masked such that they are not used when iterating through the grid. This is an efficient implementation of sparse-like grids which maintain their 3D grid structure while avoiding computations on unnecessary positions.","category":"page"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"Masked dose grids (DoseGridMasked) can be constructed by suppling grid axes and a vector of CartesianIndex where the points are enabled:","category":"page"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"indices = [CartesianIndex(1, 1, 1), CartesianIndex(2, 4, 1)]\npos = DoseGridMasked(axes, indices);","category":"page"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"In this example, only positions at indices [1, 1, 1] and [2, 4, 1] are not masked and used in iteration:","category":"page"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"for i in eachindex(pos)\n    @show i, pos[i]\nend","category":"page"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"When using a bounding object, the dose grid dimensions are set to encompass the whole bounding object, but points outside the bounding object are masked. For example, a masked dose grid bounded by a cylinder will produce the following:","category":"page"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"pos = DoseGridMasked(5., CylinderBounds(10., 10.));\ngetaxes(pos)\nlength(pos)","category":"page"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"While the axes still encompass the cylinder, the number of points (length) are less (15<5^3).","category":"page"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"Linear indexing is supported, and Cartesian indexing will work if the index is not masked. For example the following will work,","category":"page"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"pos[2]\npos[1,1,1]","category":"page"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"Suppling an index where the point is masked will throw a BoundsError,","category":"page"},{"location":"DosePositions/","page":"Dose Positions","title":"Dose Positions","text":"pos[1,2,1]","category":"page"},{"location":"DoseReconstruction/#Dose-Reconstruction-from-a-Treatment-Plan","page":"Dose Reconstruction from a Treatment Plan","title":"Dose Reconstruction from a Treatment Plan","text":"","category":"section"},{"location":"DoseReconstruction/","page":"Dose Reconstruction from a Treatment Plan","title":"Dose Reconstruction from a Treatment Plan","text":"Roentgen.jl provides a high-level interface to reconstructing dose, enabling quick and easy dose reconstructions.","category":"page"},{"location":"DoseReconstruction/","page":"Dose Reconstruction from a Treatment Plan","title":"Dose Reconstruction from a Treatment Plan","text":"reconstruct_dose takes a dose volume, Treatment Plan and a dose calculation algorithm, and computes the dose for all fields in the plan. An example of this is provided in the Dose Reconstruction notebook.","category":"page"},{"location":"DoseReconstruction/","page":"Dose Reconstruction from a Treatment Plan","title":"Dose Reconstruction from a Treatment Plan","text":"reconstruct_dose","category":"page"},{"location":"DoseReconstruction/#Roentgen.reconstruct_dose","page":"Dose Reconstruction from a Treatment Plan","title":"Roentgen.reconstruct_dose","text":"reconstruct_dose(vol::AbstractDoseVolume, plan::AbstractTreatmentPlan,\n    calc::AbstractDoseAlgorithm; Δx=5., show_progress=true)\n\nDose reconstruction from a treatment plan.\n\nRequires a dose volume (vol), a treatment plan (plan), and a dose calculationalgorithm (calc).  Optional arguments include:\n\nΔx: Size of each bixel in the fluence grid (defaults to 5.)\nshow_progress: If true (default), displays the progress\n\n\n\n\n\n","category":"function"},{"location":"TreatmentPlan/#Treatment-Plan","page":"Treatment Plan","title":"Treatment Plan","text":"","category":"section"},{"location":"TreatmentPlan/","page":"Treatment Plan","title":"Treatment Plan","text":"Roentgen.jl supports the usage of treatment plans. These are typically stored in the DICOM RP file format.","category":"page"},{"location":"TreatmentPlan/","page":"Treatment Plan","title":"Treatment Plan","text":"Treatment plans consist of a number of treatment fields, which specify machine patient setup parameters.","category":"page"},{"location":"TreatmentPlan/","page":"Treatment Plan","title":"Treatment Plan","text":"Each treatment field is essentially a vector of control points (i.e. Vector{ControlPoint}). Indexing a treatment field will return a Roentgen.ControlPoint,","category":"page"},{"location":"TreatmentPlan/","page":"Treatment Plan","title":"Treatment Plan","text":"control_point = field[1]","category":"page"},{"location":"TreatmentPlan/","page":"Treatment Plan","title":"Treatment Plan","text":"Iterating a field will return each control point sequentially.","category":"page"},{"location":"TreatmentPlan/#DICOM","page":"Treatment Plan","title":"DICOM","text":"","category":"section"},{"location":"TreatmentPlan/","page":"Treatment Plan","title":"Treatment Plan","text":"Treatment plans can be loaded in from a DICOM RP file using,","category":"page"},{"location":"TreatmentPlan/","page":"Treatment Plan","title":"Treatment Plan","text":"plan = load_dicom(\"path/to/RP....dcm\")","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [Roentgen]","category":"page"},{"location":"API/#Roentgen.AbstractBeamLimitingDevice","page":"API","title":"Roentgen.AbstractBeamLimitingDevice","text":"Abstract type for Beam Limiting Devices are based on\n\nAbstractBeamLimitingDevice contains the types for MultiLeafCollimators, Jaws, etc.\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.AbstractBixel","page":"API","title":"Roentgen.AbstractBixel","text":"AbstractBixel\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.AbstractDoseAlgorithm","page":"API","title":"Roentgen.AbstractDoseAlgorithm","text":"AbstractDoseAlgorithm\n\nSupertype for Dose Algorithms\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.AbstractDoseGrid","page":"API","title":"Roentgen.AbstractDoseGrid","text":"AbstractDoseGrid\n\nA type of Dose Positions on a regular grid.\n\nMust have axes field defined.\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.AbstractExternalSurface","page":"API","title":"Roentgen.AbstractExternalSurface","text":"AbstractExternalSurface\n\nSupertype for external surfaces.\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.AbstractFluenceElement","page":"API","title":"Roentgen.AbstractFluenceElement","text":"AbstractFluenceElement\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.AbstractTreatmentField","page":"API","title":"Roentgen.AbstractTreatmentField","text":"Treatment Field\n\nAbstract treatment field, basis for containing multiple treatment types (e.g. VMAT, IMRT, etc.)\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.Beamlet-Tuple{Bixel, GantryPosition}","page":"API","title":"Roentgen.Beamlet","text":"Beamlet(bixel::Bixel, gantry)\n\nConstruct a beamlet from a bixel\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.Bixel","page":"API","title":"Roentgen.Bixel","text":"Bixel{T}\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.BixelGrid-NTuple{4, Any}","page":"API","title":"Roentgen.BixelGrid","text":"BixelGrid(x, y, Δx[, Δy])\n\nConstruct a grid of bixels.\n\nEach axis starts at the first element (e.g. x[1]), runs to the last element (x[end]), with uniform spacing (Δx). Same for y. Positions are \"snapped\" to the spacing value (see snapped_range for details).\n\nIf Δy not specified, assumes Δy = Δx.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.BixelGrid-Tuple{Jaws, Any, Any}","page":"API","title":"Roentgen.BixelGrid","text":"BixelGrid(jaws::Jaws, Δx[, Δy])\n\nUses the jaw positions to construct a bixel grid.\n\nIf Δy not specified, assumes Δy = Δx\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.ConstantSurface","page":"API","title":"Roentgen.ConstantSurface","text":"ConstantSurface\n\nAn external surface with a constant source surface distance, regardless of the position. This surface is largely used for testing purposes as its inherently unphysical.\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.ControlPoint","page":"API","title":"Roentgen.ControlPoint","text":"ControlPoint\n\nElements of a TreatmentField\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.CylinderBounds","page":"API","title":"Roentgen.CylinderBounds","text":"CylinderBounds{T}\n\nRepresents a cylinder about the z axis.\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.CylindricalSurface","page":"API","title":"Roentgen.CylindricalSurface","text":"CylindricalSurface(y::TRange, ϕ::TRange, rho::TInterp)\n\nSurface stored on a cylindrical-polar grid.\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.CylindricalSurface-2","page":"API","title":"Roentgen.CylindricalSurface","text":"CylindricalSurface(mesh::SimpleMesh, y::AbstractRange[, nϕ=181])\n\nConstruct from mesh over axial axis y.\n\nDefaults to a 2° azimuthal spacing (nϕ=181).\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.CylindricalSurface-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractVector}","page":"API","title":"Roentgen.CylindricalSurface","text":"CylindricalSurface(ϕ::AbstractVector, y::AbstractVector, rho::AbstractMatrix)\n\nConstructed using vectors for ϕ, y, and rho.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.CylindricalSurface-Tuple{Meshes.SimpleMesh, Real, Vararg{Any}}","page":"API","title":"Roentgen.CylindricalSurface","text":"CylindricalSurface(mesh::SimpleMesh, Δy::Real[, nϕ=181])\n\nConstruct from mesh over with axial spacing y.\n\nUses the mesh bounds to compute the axial range. Defaults to a 2° azimuthal spacing (nϕ=181).\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.DoseGrid","page":"API","title":"Roentgen.DoseGrid","text":"DoseGrid(Δ, bounds::AbstractBounds)\n\nConstruct a DoseGrid with spacing Δ within bounds.\n\nCan specify a coordinate system transformation in transform to generate dose points in a different coordinate system to the bounds.\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.DoseGrid-2","page":"API","title":"Roentgen.DoseGrid","text":"DoseGrid\n\nCartesian Dose Grid\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.DoseGridMasked","page":"API","title":"Roentgen.DoseGridMasked","text":"DoseGridMasked(Δ, bounds::AbstractBounds, transform=I)\n\nConstruct a DoseGridMasked with spacing Δ within bounds.\n\nThe mask applies to all points within bounds. Can specify a coordinate system transformation in transform to generate dose points in a different coordinate system to the bounds.\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.DoseGridMasked-2","page":"API","title":"Roentgen.DoseGridMasked","text":"DoseGridMasked\n\nCartesian Dose Grid with a mask to reduce the number of dose points used.\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.DoseVolume","page":"API","title":"Roentgen.DoseVolume","text":"DoseVolume\n\nStores dose positions and an external surface\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.FinitePencilBeamKernel","page":"API","title":"Roentgen.FinitePencilBeamKernel","text":"FinitePencilBeamKernel(parameters, scalingfactor, depth, tanθ)\n\nDose calculation for Finite Pencil Beam Kernel algorithm (Jelen 2005).\n\nTakes the following commissioned parameters:\n\nparameters: Weights and steepness parameters by depth\nscalingfactor: Scaling factor matrix by depth and tanθ\ndepth: Depths of parameters of scaling factor values\ntanθ: Angle from central beam axis of scaling factor value\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.FinitePencilBeamKernel-Tuple{String}","page":"API","title":"Roentgen.FinitePencilBeamKernel","text":"FinitePencilBeamKernel(filename::String)\n\nLoad commissioned parameters from a .jld file.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.GantryPosition","page":"API","title":"Roentgen.GantryPosition","text":"GantryPosition{T}\n\nThe position/rotation of the gantry and beam-limiting device.\n\nStores:\n\ngantry_angle: As defined by IEC\ncollimator_angle: As defined by IEC (beam limiting device angle)\nsource_axis_distance: Distance between source and isocenter\ncentral_beam_axis: Unit vector pointing from the isocenter to the source in IEC Fixed coordinates.\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.Jaws","page":"API","title":"Roentgen.Jaws","text":"Jaws\n\nJaws stores the x and y positions of the jaws.\n\nThe x/y positions of the jaws can be accessed through the getx/gety methods.\n\nThe usual constructor directly takes the jaw x and y position vectors, but a single fieldsize can also be specified.\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.Jaws-Tuple{T} where T<:AbstractFloat","page":"API","title":"Roentgen.Jaws","text":"Jaws(fieldsize::T)\n\nCreate jaws with a square field of length fieldsize.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.LinearSurface","page":"API","title":"Roentgen.LinearSurface","text":"LinearSurface(params::AbstractVector)\n\nConstructed with a vector of 6 element parameters corresponding to the plane  position and normal at gantry angles.\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.LinearSurface-Union{Tuple{Meshes.SimpleMesh{3, T, V} where V<:AbstractArray{Meshes.Point{3, T}, 1}}, Tuple{T}} where T<:Real","page":"API","title":"Roentgen.LinearSurface","text":"LinearSurface(mesh[, SAD=1000, ΔΘ=deg2rad(1)])\n\nConstruct a LinearSurface from a mesh.\n\nComputes a set of planes parallel to the surface of the mesh.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.MeshBounds","page":"API","title":"Roentgen.MeshBounds","text":"MeshBounds{T, TMesh}\n\nRepresents a surface from a mesh.\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.MeshSurface","page":"API","title":"Roentgen.MeshSurface","text":"MeshSurface\n\nAn external surface defined by a 3D mesh.\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.MockKernel","page":"API","title":"Roentgen.MockKernel","text":"MockKernel\n\nA mock dose algorithm used as an example and tests\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.MultiLeafCollimator","page":"API","title":"Roentgen.MultiLeafCollimator","text":"MultiLeafCollimator\n\nMultiLeafCollimator stores the leaf positions and edges of an MLC.\n\nThe 2 by n leaf positions are stored in the positions matrix. The leaf position boundaries are stored in the edges vector, which is 1 element longer than the number of leaf tracks, n.\n\nIndexing a MultiLeafCollimator will either return the x and y bounds of the leaf track, or another MultiLeafCollimator. It also supports the @view macro. Iteration goes through each leaf track, returning the lower and upper boundaries.\n\nA MultiLeafCollimator can also be shifted through addition or subtraction, and scaled with multplication and division.\n\nThe locate method is implemented to return the leaf index containing edge position.\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.MultiLeafCollimator-Tuple{Any}","page":"API","title":"Roentgen.MultiLeafCollimator","text":"MultiLeafCollimator(n::Int, Δy::Real)\n\nConstruct an MLC with leaf edges.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.MultiLeafCollimator-Tuple{Int64, Real}","page":"API","title":"Roentgen.MultiLeafCollimator","text":"MultiLeafCollimator(n::Int, Δy::Real)\n\nConstruct an MLC with n number of leaves and of leaf width Δy, centered about zero.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.MultiLeafCollimatorSequence","page":"API","title":"Roentgen.MultiLeafCollimatorSequence","text":"MultiLeafCollimatorSequence\n\nMultiLeafCollimatorSequence stores a sequence of MLC apertures.\n\nThe 2 by n leaf positions are stored in the positions matrix. The leaf position boundaries are stored in the edges vector, which is 1 element longer than the number of leaf tracks, n.\n\nIndexing a MultiLeafCollimator will either return the x and y bounds of the leaf track, or another MultiLeafCollimator. It also supports the @view macro. Iteration goes through each leaf track, returning the lower and upper boundaries.\n\nA MultiLeafCollimator can also be shifted through addition or subtraction, and scaled with multplication and division.\n\nThe locate method is implemented to return the leaf index containing edge position.\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.PlaneSurface","page":"API","title":"Roentgen.PlaneSurface","text":"PlaneSurface\n\nA plane at a constant distance from and normal towards the source\n\nThe source-surface distance is stored in surf.source_surface_distance\n\n\n\n\n\n","category":"type"},{"location":"API/#Roentgen.SurfaceBounds","page":"API","title":"Roentgen.SurfaceBounds","text":"SurfaceBounds{TSurface}\n\nRepresents a surface from a mesh.\n\n\n\n\n\n","category":"type"},{"location":"API/#Base.getindex-Tuple{Bixel, Int64}","page":"API","title":"Base.getindex","text":"Base.getindex(bixel::Bixel, i::Int)\n\nGet the centre position of the bixel.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.iterate-Tuple{Roentgen.AbstractTreatmentField}","page":"API","title":"Base.iterate","text":"iterate\n\nIteration of a treatment field, returning ControlPoint every time iterate is called.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen._assert_size-Tuple{Any, Any, Any}","page":"API","title":"Roentgen._assert_size","text":"_assert_size(D, pos, beamlets)\n\nEnsures size of D is correct\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen._get_cells-Tuple{Any}","page":"API","title":"Roentgen._get_cells","text":"_get_cells(pos)\n\nReturns a list of cell connectivities\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen._sequential_searchsortedlast-Tuple{Any, Any, Any}","page":"API","title":"Roentgen._sequential_searchsortedlast","text":"_sequential_searchsortedlast(a, x, jstart)\n\nA searchsortedlast where the index is near and greater than previous index\n\nThis assumes that the next index is larger than the starting index jstart. It first checks that jstart already satisfies a[j]<=x<a[j+1]. If not, it searches for j>jstart, returning length(a) if a[end]<x.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen._vtk_create_cell-Tuple{Any}","page":"API","title":"Roentgen._vtk_create_cell","text":"_vtk_create_cell(cell)\n\nReturn the VTK cell type for a list of cell indices.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.bixels_from_bld","page":"API","title":"Roentgen.bixels_from_bld","text":"bixels_from_bld(args::AbstractBeamLimitingDevice...)\n\nCreate bixels corresponding to the provided beam limiting devices.\n\n\n\n\n\n","category":"function"},{"location":"API/#Roentgen.bixels_from_bld-Union{Tuple{T}, Tuple{Roentgen.AbstractMultiLeafCollimator, Jaws{T}}} where T<:AbstractFloat","page":"API","title":"Roentgen.bixels_from_bld","text":"bixels_from_bld(mlcx, mlc::MultiLeafCollimator, jaws::Jaws)\n\nFrom MultiLeafCollimator and Jaws.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.bld_to_fixed-Tuple{Any, Any, Any}","page":"API","title":"Roentgen.bld_to_fixed","text":"bld_to_fixed(ϕg, θb, SAD)\n\nConvert from IEC BLD to IEC fixed coordinates\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.bld_to_gantry-Union{Tuple{T}, Tuple{Any, T}} where T<:AbstractFloat","page":"API","title":"Roentgen.bld_to_gantry","text":"bld_to_gantry(θb, SAD)\n\nConvert from IEC BLD to IEC gantry coordinates\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.calibrate!","page":"API","title":"Roentgen.calibrate!","text":"calibrate!(calc, MU, fieldsize, SAD[, SSD=SAD])\n\nCalibrate a dose algorithm with given MU, fielsize and SAD.\n\nScales the dose such that the maximum dose is 1 Gy for MU monitor units, given fieldsize and source-axis distance (SAD). Can set source-surface distance SSD if SSD!=SAD.\n\n\n\n\n\n","category":"function"},{"location":"API/#Roentgen.closest_intersection-Tuple{Any, Any, Any, Vararg{Any}}","page":"API","title":"Roentgen.closest_intersection","text":"closest_intersection(p1, p2, mesh::Domain)\n\nReturn the point on the line p1->p2 and mesh closest to p1\n\nFinds all points of intersection, then returns the point closest to p1. If no intersections are found, it returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.dose_fluence_matrix!","page":"API","title":"Roentgen.dose_fluence_matrix!","text":"dose_fluence_matrix!(D<:AbstractMatrix, pos, beamlets, surf, calc)\n\nCompute a dose-fluence matrix from dose positions, beamlets, external surface and dose calculation algorithm.\n\nRequires the point_dose method to be defined for the given dose calculation algorithm (calc). point_dose computes the dose at a given position from a given beamlet.\n\nIt stores result in D<:AbstractMatrix. Currently, the following matrix types are supported:\n\nD::Matrix\nD::SparseMatrixCSC\nD::CuArray\n\n\n\n\n\n","category":"function"},{"location":"API/#Roentgen.dose_fluence_matrix!-Tuple{Any, Roentgen.AbstractDoseVolume, Any, Any}","page":"API","title":"Roentgen.dose_fluence_matrix!","text":"dose_fluence_matrix!(D, vol, beamlets, calc)\n\nGets positions and surface from vol\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.dose_fluence_matrix-Tuple{Any, Roentgen.AbstractDoseVolume, Any, Any}","page":"API","title":"Roentgen.dose_fluence_matrix","text":"dose_fluence_matrix(T, vol, beamlets, calc)\n\nGets positions and surface from vol\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.dose_fluence_matrix-Tuple{Type{<:AbstractMatrix}, Any, AbstractArray{<:Roentgen.AbstractBeamlet}, Roentgen.AbstractExternalSurface, Roentgen.AbstractDoseAlgorithm}","page":"API","title":"Roentgen.dose_fluence_matrix","text":"dose_fluence_matrix(T, pos, beamlets, surf, calc)\n\nCompute a dose-fluence matrix from dose positions, beamlets, external surface and dose calculation algorithm.\n\nT is the matrix type. It currently supports:\n\nMatrix: Dense CPU\nSparseMatrixCSC: Sparse CPU\nCuArray: Dense GPU\n\ne.g. dose_fluence_matrix(SparseMatrixCSC, ...) will create a sparse matrix computed using the CPU.\n\nSee dose_fluence_matrix! for implementation.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.dose_kernel!-Tuple{SparseArrays.SparseMatrixCSC, Vararg{Any, 4}}","page":"API","title":"Roentgen.dose_kernel!","text":"dose_kernel!(rowval, nzval, pos::AbstractVector{T}, bixels, surf, calc)\n\nCompute the fluence kernel for a given position.\n\nDesigned to be used with a dose-fluence matrix of type SparseMatrixCSC. Stores the row value in rowval, and dose value in nzval.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.extent-Tuple{CylinderBounds}","page":"API","title":"Roentgen.extent","text":"extent(bounds::CylinderBounds)\n\nFor a cylinder\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.extent-Tuple{MeshBounds}","page":"API","title":"Roentgen.extent","text":"extent(bounds::MeshBounds)\n\nFor a mesh\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.extent-Tuple{Roentgen.AbstractBounds}","page":"API","title":"Roentgen.extent","text":"extent(bounds::AbstractBounds)\n\nReturns the bounding box of the bounds as two vectors: pmin, pmax\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.extent-Tuple{SurfaceBounds}","page":"API","title":"Roentgen.extent","text":"extent(bounds::SurfaceBounds)\n\nFor a mesh\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.fixed_to_bld-Tuple{Any, Any, Any}","page":"API","title":"Roentgen.fixed_to_bld","text":"fixed_to_bld(ϕg, θb, SAD)\n\nConvert from IEC fixed to IEC BLD coordinates\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.fixed_to_gantry-Tuple{Any}","page":"API","title":"Roentgen.fixed_to_gantry","text":"fixed_to_gantry(ϕg)\n\nConvert from IEC fixed to IEC gantry coordinates\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.fluence!-Tuple{AbstractArray{<:AbstractFloat}, AbstractArray{<:Roentgen.AbstractBixel}, AbstractArray{Int64}, Vararg{Any}}","page":"API","title":"Roentgen.fluence!","text":"fluence!(Ψ::AbstractArray{<:AbstractFloat}, bixels::AbstractArray{<:AbstractBixel}, index::AbstractArray{Int}, args...)\n\nStores the result in Ψ. See fluence(bixels::AbstractArray{<:AbstractBixel}, index::AbstractArray{Int}, args...) for details\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.fluence!-Tuple{AbstractArray{<:AbstractFloat}, AbstractArray{<:Roentgen.AbstractBixel}, Vararg{Any}}","page":"API","title":"Roentgen.fluence!","text":"fluence!(Ψ::AbstractArray{<:AbstractFloat}, bixels::AbstractArray{<:AbstractBixel}, args...)\n\nCompute the fluence on a collection of bixels, storing the result in Ψ.\n\nSee fluence(bixels::AbstractArray{<:AbstractBixel}, args...) for details.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.fluence-Tuple{AbstractArray{<:Roentgen.AbstractBixel}, AbstractArray{Int64}, Vararg{Any}}","page":"API","title":"Roentgen.fluence","text":"fluence(bixels::AbstractArray{<:AbstractBixel}, index::AbstractArray{Int}, args...)\n\nAllows precomputation of the location of the bixel in relation to the beam limiting device.\n\nIn the case of an MLC, the index is the leaf index that contains that bixel.\n\nRequires fluence(bixel::AbstractBixel, index::Int, args...) to be defined for the particular beam limiting device\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.fluence-Tuple{AbstractArray{<:Roentgen.AbstractBixel}, Vararg{Any}}","page":"API","title":"Roentgen.fluence","text":"fluence(bixels::AbstractArray{<:AbstractBixel}, bld::AbstractBeamLimitingDevice, args...)\n\nCompute the fluence on a collection of bixels.\n\nBroadcasts over the specific fluence(bixel, ...) method for the provided beam limiting device. e.g.: fluence(bixels, jaws), fluence(bixels, mlcx, mlc)\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.fluence-Tuple{Bixel, Jaws}","page":"API","title":"Roentgen.fluence","text":"fluence(bixel::Bixel, jaws::Jaws)\n\nFrom the Jaws.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.fluence-Tuple{Roentgen.AbstractBixel, Int64, AbstractMatrix, AbstractMatrix}","page":"API","title":"Roentgen.fluence","text":"fluence(bixel::Bixel{T}, index::Int, mlcx1, mlcx2)\n\nFrom an MLC aperture sequence using a given leaf index.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.fluence-Tuple{Roentgen.AbstractBixel, Int64, AbstractMatrix}","page":"API","title":"Roentgen.fluence","text":"fluence(bixel::Bixel, index::Int, mlcx)\n\nFrom an MLC aperture using a given leaf index.\n\nThis method assumes the bixel is entirely within the ith leaf track, and does not overlap with other leaves. Does not check whether these assumptions are true.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.fluence-Tuple{Roentgen.AbstractBixel, Roentgen.AbstractBeamLimitingDevice, Vararg{Any}}","page":"API","title":"Roentgen.fluence","text":"fluence(bixel::AbstractBixel, bld::AbstractBeamLimitingDevice, args...)\n\nCompute the fluence of bixel from beam limiting device (e.g. an MLC or jaws).\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.fluence-Union{Tuple{T}, Tuple{Bixel{T}, MultiLeafCollimator, MultiLeafCollimator}} where T<:AbstractFloat","page":"API","title":"Roentgen.fluence","text":"fluence(bixel::Bixel{T}, mlc1::MultiLeafCollimator, mlc2::MultiLeafCollimator)\n\nFrom an MLC aperture sequence.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.fluence-Union{Tuple{T}, Tuple{Bixel{T}, MultiLeafCollimator}} where T<:AbstractFloat","page":"API","title":"Roentgen.fluence","text":"fluence(bixel::Bixel, mlc::MultiLeafCollimator)\n\nFrom an MLC aperture.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.fluence_from_moving_aperture-Union{Tuple{T}, Tuple{Bixel{T}, Any, Any}} where T<:AbstractFloat","page":"API","title":"Roentgen.fluence_from_moving_aperture","text":"fluence_from_moving_aperture(bixel::Bixel{T}, mlcx1, mlcx2)\n\nFrom MLC leaf positions which move from mlcx1 to mlcx2.\n\nComputes the time-weighted fluence as the MLC moves from position mlcx1 to mlcx2. Assumes the MLC leaves move in a straight line.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.fluence_from_rectangle-Tuple{Bixel, Any, Any}","page":"API","title":"Roentgen.fluence_from_rectangle","text":"fluence_from_rectangle(bixel::Bixel, xlim, ylim)\n\nCompute the fluence of a rectangle with edges at xlim and ylim on a bixel.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.fluence_onesided-NTuple{4, Any}","page":"API","title":"Roentgen.fluence_onesided","text":"fluence_onesided(xs, xf, xL, xU)\n\nCompute fluence for 1 leaf position, assuming the other is infinitely far away\n\nComputes the fluence for a leaf trajectory from xs to xf, over a bixel from xL to xU. The aperture is considered open to the right of the leaf position (i.e. leaf on the B bank). Assumes the bixel is fully in the leaf track.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.gantry_to_bld-Union{Tuple{T}, Tuple{Any, T}} where T<:AbstractFloat","page":"API","title":"Roentgen.gantry_to_bld","text":"gantry_to_bld(θb, SAD)\n\nConvert from IEC gantry to IEC BLD coordinates\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.gantry_to_fixed-Tuple{Any}","page":"API","title":"Roentgen.gantry_to_fixed","text":"gantry_to_fixed(ϕg)\n\nConvert from IEC gantry to IEC fixed coordinates\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.getSSD-Tuple{ConstantSurface, Any, Any}","page":"API","title":"Roentgen.getSSD","text":"getSSD(calc::ConstantSurface, pos, src)\n\nWhen applied to a ConstantSurface, it returns a constant source surface distance, regardless of pos.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.getSSD-Tuple{PlaneSurface, Any, Any}","page":"API","title":"Roentgen.getSSD","text":"getSSD(surf::PlaneSurface, pos, src)\n\nWhen applied to a PlaneSurface, it returns the distance to the plane.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.getSSD-Tuple{Roentgen.AbstractExternalSurface, Any, Any}","page":"API","title":"Roentgen.getSSD","text":"getSSD(surf::AbstractExternalSurface, pos, src)\n\nGet the Source-Surface Distance (SSD) for position pos to the radiation source src.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.getarea-Tuple{Bixel}","page":"API","title":"Roentgen.getarea","text":"getarea(bixel::Bixel)\n\nReturn the area of the bixel.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.getaxes-Tuple{DoseGridMasked}","page":"API","title":"Roentgen.getaxes","text":"getaxes(pos::DoseGrid[, dim])\n\nReturn the axes of the grid.\n\nOptionally, can specify which dimension.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.getaxes-Tuple{Roentgen.AbstractDoseGrid}","page":"API","title":"Roentgen.getaxes","text":"getaxes(pos::AbstractDoseGrid[, dim])\n\nReturn the axes of the grid.\n\nOptionally, can specify which dimension.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.getcenter-Tuple{Bixel, Int64}","page":"API","title":"Roentgen.getcenter","text":"getcenter(bixel::Bixel, i::Int)\n\nGet the ith coordinate of the position.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.getcenter-Tuple{Bixel}","page":"API","title":"Roentgen.getcenter","text":"getcenter(bixel::Bixel)\n\nGet the position of the bixel.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.getdepth-Tuple{Roentgen.AbstractExternalSurface, Any, Any}","page":"API","title":"Roentgen.getdepth","text":"getdepth(surf::AbstractExternalSurface, pos, src)\n\nGet the depth of the position pos below the surface from the radiation source src.\n\nComputes the depth by subtracting \n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.getedge-Tuple{Bixel, Vararg{Any}}","page":"API","title":"Roentgen.getedge","text":"getedge(bixel::Bixel[, dim::Int])\n\nReturn the lower edge of the bixel.\n\nCan specify a dim for which dimension (x or y).\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.getpositions-Tuple{DoseVolume}","page":"API","title":"Roentgen.getpositions","text":"getpositions(vol::DoseVolume)\n\nGet dose positions/grid\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.getsurface-Tuple{DoseVolume}","page":"API","title":"Roentgen.getsurface","text":"getsurface(vol::DoseVolume)\n\nGet surface\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.getwidth-Tuple{Bixel, Int64}","page":"API","title":"Roentgen.getwidth","text":"getwidth(bixel::Bixel, i::Int)\n\nReturn the width of the bixel along axis i.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.getwidth-Tuple{Bixel}","page":"API","title":"Roentgen.getwidth","text":"getwidth(bixel::Bixel)\n\nReturn the width of the bixel.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.hypotenuse-Tuple{Any, Any}","page":"API","title":"Roentgen.hypotenuse","text":"hypotenuse(a, b)\n\nCompute the hypotenuse of triangle\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.interp-Tuple{AbstractVector, AbstractVector, AbstractMatrix, Any, Any}","page":"API","title":"Roentgen.interp","text":"interp(xg::AbstractVector, yg::AbstractVector, fg::AbstractMatrix, xi, yi)\n\nBilinear interpolation at position xi,yi, on grid xg-yg with values fg\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.interp-Tuple{Any, Any, Any}","page":"API","title":"Roentgen.interp","text":"interp(f1, f2, α)\n\nInterpolate using given values f1 and f2 and the scaled distance from them α\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.interp-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Any}} where T<:Real","page":"API","title":"Roentgen.interp","text":"interp(xg::AbstractVector{T}, fg::AbstractVector{T}, xi) where T<:Real\n\nInterpolate xi within uniform grid positions xg and grid values fg\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.intersect_mesh-Union{Tuple{T}, Tuple{Dim}, Tuple{Meshes.Segment, Meshes.Domain{Dim, T}}} where {Dim, T}","page":"API","title":"Roentgen.intersect_mesh","text":"intersect_mesh(s, mesh)\n\nFind the intersection points of the line and the mesh.\n\nReturns a list of intersection points, and an empty list if none present.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.intersect_mesh-Union{Tuple{T}, Tuple{Dim}, Tuple{Meshes.Segment{Dim, T}, Meshes.Partition{<:Meshes.Domain{Dim, T}}, Any}} where {Dim, T}","page":"API","title":"Roentgen.intersect_mesh","text":"intersect_mesh(line::Segment, mesh::Partition[, boxes])\n\nIntersect a partitioned mesh.\n\nWill check intersection with the bounding box of each partition before checking  for intersection between each cell. Can pre-compute bounding boxes for extra performance. Single threaded.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.leaf_trajectory-Tuple{Any, Any, Any}","page":"API","title":"Roentgen.leaf_trajectory","text":"leaf_trajectory(x, x1, x2)\n\nCompute the height of position x between (x1, 0) and (x2, 1)\n\nUsed in intersection_area.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.load_beam-Tuple{Any, Any}","page":"API","title":"Roentgen.load_beam","text":"load_beam(beam, total_meterset)\n\nLoad a beam from a control point sequence in a DICOM RP file.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.load_dicom-Tuple{Any}","page":"API","title":"Roentgen.load_dicom","text":"load_dicom(filename)\n\nLoad a DICOM RP file into a Vector{TreatmentField}.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.load_ref_dose-Tuple{Any}","page":"API","title":"Roentgen.load_ref_dose","text":"load_ref_dose(beam)\n\nLoad a reference dose, used for calculating the meterset in a control point sequence\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.load_structure_from_ply-Tuple{Any}","page":"API","title":"Roentgen.load_structure_from_ply","text":"load_structure_from_ply(filename)\n\nLoad a .ply file into a mesh\n\nUses MeshIO to load the mesh from the file. Unfortunately, MeshIO loads into GeometryBasics.Mesh, not Meshes.SimpleMesh. The rest of the code converts the mesh into a Meshes.SimpleMesh. From https://github.com/JuliaIO/MeshIO.jl/issues/67#issuecomment-913353708\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.locate-Tuple{Any, Any, Any}","page":"API","title":"Roentgen.locate","text":"locate(x::T, start::T, step::T) where T<:AbstractFloat\n\nLocate the grid index for position xi\n\nSpecify the grid starting position (start) and grid spacing (step).\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.locate-Tuple{Roentgen.AbstractMultiLeafCollimator, Any}","page":"API","title":"Roentgen.locate","text":"locate(mlc::AbstractMultiLeafCollimator, x::Number)\n\nLocate the track index i which contains the position x\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.locate-Union{Tuple{T}, Tuple{AbstractRange{T}, T}} where T<:Real","page":"API","title":"Roentgen.locate","text":"locate(xg::AbstractRange{T}, xi::T) where T<:Real\n\nWhen a range is provided, uniform spacing can be assumed.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.locate-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T<:Real","page":"API","title":"Roentgen.locate","text":"locate(xg::AbstractVector{T}, xi::T) where T<:Real\n\nLocates the grid index for position x within a grid xg. Does not limit out of bounds indices.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.overlap-NTuple{4, Number}","page":"API","title":"Roentgen.overlap","text":"overlap(x, Δx, xB, xA)\n\nCompute the overlapping length of a bixel spanning x-w/2->x+w/2 and the length between xL and xU, normalised to the length of the bixel. If the Bixel fully within range (xL<=x-w/2 && x+w/2<=xU), return 1. If the bixel is fully outside the range (xU<=x-w/2 || x+w/2<=xL), return 0.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.patient_to_fixed-Tuple{Any}","page":"API","title":"Roentgen.patient_to_fixed","text":"patient_to_fixed(isocenter)\n\nConvert from the patient-based coordinate system to IEC Fixed.\n\nIsocenter is in the patient-based coordinate system, as specified in the DICOM RP file.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.point_dose","page":"API","title":"Roentgen.point_dose","text":"point_dose(p::SVector{3}, beamlet::Beamlet, surf::AbstractExternalSurface, calc::AbstractDoseAlgorithm)\n\nCompute the dose at position p from beamlet using a dose algorithm. \n\n\n\n\n\n","category":"function"},{"location":"API/#Roentgen.point_dose-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, Beamlet, Roentgen.AbstractExternalSurface, FinitePencilBeamKernel}} where T<:AbstractFloat","page":"API","title":"Roentgen.point_dose","text":"point_dose(..., calc::FinitePencilBeamKernel)\n\nUsing the Finite Pencil Beam Kernel algorithm\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.reconstruct_dose-Tuple{Roentgen.AbstractDoseVolume, AbstractVector{<:Roentgen.AbstractTreatmentField}, Roentgen.AbstractDoseAlgorithm}","page":"API","title":"Roentgen.reconstruct_dose","text":"reconstruct_dose(vol::AbstractDoseVolume, plan::AbstractTreatmentPlan,\n    calc::AbstractDoseAlgorithm; Δx=5., show_progress=true)\n\nDose reconstruction from a treatment plan.\n\nRequires a dose volume (vol), a treatment plan (plan), and a dose calculationalgorithm (calc).  Optional arguments include:\n\nΔx: Size of each bixel in the fluence grid (defaults to 5.)\nshow_progress: If true (default), displays the progress\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.resample-Union{Tuple{T}, Tuple{Any, T}} where T<:Number","page":"API","title":"Roentgen.resample","text":"resample(field, Δη::T; by=:MU)\n\nResample at uniform steps Δη, from start to finish.\n\nSee resample(field, ηₛ::AbstractVector{T}; by=:MU) for details.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.resample-Union{Tuple{T}, Tuple{Roentgen.AbstractTreatmentField, AbstractVector{T}}} where T<:AbstractFloat","page":"API","title":"Roentgen.resample","text":"resample(field, ηₛ::AbstractVector{T}; by=:time)\n\nResample a treatment field onto new times or meterset values.\n\nCan resample either by time (by=:time) or MU (by=:MU, default).\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.scale_to_cell-Tuple{Any, Any, Any}","page":"API","title":"Roentgen.scale_to_cell","text":"scale_to_cell(x1, x2, xi)\n\nScale the position xi within the positions x1 and x2.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.scale_to_isoplane-Tuple{Any, Any}","page":"API","title":"Roentgen.scale_to_isoplane","text":"scale_to_isoplane(pᵢ, z_plane)\n\nScale the position pᵢ to the plane at distance z_plane.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.snapped_range-Tuple{Any, Any, Any}","page":"API","title":"Roentgen.snapped_range","text":"snapped_range(x1, x2, Δ)\n\nCreate a range from x1 to x2 which is \"snapped\" to the step Δ.\n\nPositions are \"snapped\" to the step value (e.g. a starting position of x[1]-0.2Δx snaps to x[1]-Δx). The new range always includes the start and end points of the original range\n\nExamples:\n\n0.1:1.:9.4 -> 0:1.:10.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.subdivide-Tuple{Bixel, Integer, Integer}","page":"API","title":"Roentgen.subdivide","text":"subdivide(bixel::Bixel, nx::Integer, ny::Integer)\n\nSubdivide a bixel by specifing the number of partitions nx and ny.\n\nReturns a grid of bixels.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.subdivide-Union{Tuple{T}, Tuple{Bixel{T}, T, T}} where T<:AbstractFloat","page":"API","title":"Roentgen.subdivide","text":"subdivide(bixel::Bixel{T}, δx::T, δy::T)\n\nSubdivide by specifing widths δx and δy\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.transform!-Tuple{Any, Any}","page":"API","title":"Roentgen.transform!","text":"transform!(mesh::SimpleMesh, trans)\n\nApply general transformation trans to mesh, modifying the original mesh.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.transform-Tuple{Meshes.SimpleMesh, Any}","page":"API","title":"Roentgen.transform","text":"transform(mesh::SimpleMesh, trans)\n\nApply general transformation trans to mesh`.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.within-Tuple{CylinderBounds, Any}","page":"API","title":"Roentgen.within","text":"within(bounds::CylinderBounds, p)\n\nWhether p is within the cylinder\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.within-Tuple{MeshBounds, Any}","page":"API","title":"Roentgen.within","text":"within(bounds::MeshBounds, p)\n\nWhether p is within the mesh\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.within-Tuple{Roentgen.AbstractBounds, Any}","page":"API","title":"Roentgen.within","text":"within(bounds::AbstractBounds, p)\n\nReturns true if the point p is within bounds\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.within-Tuple{SurfaceBounds, Any}","page":"API","title":"Roentgen.within","text":"within(bounds::SurfaceBounds, p)\n\nWhether p is within the mesh\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.write_nrrd-Tuple{String, DoseGrid, AbstractArray}","page":"API","title":"Roentgen.write_nrrd","text":"write_nrrd(filename::String, pos::DoseGrid, data::AbstractArray)\n\nWrite DoseGrid to the NRRD data format.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.write_nrrd-Tuple{String, DoseGridMasked, AbstractArray}","page":"API","title":"Roentgen.write_nrrd","text":"write_nrrd(filename::String, pos::DoseGridMasked, data::AbstractArray; fillvalue=NaN)\n\nWrite DoseGridMasked to the NRRD data format.\n\nMasked points in DoseGridMasked are filled with fillvalue, defaults to NaN.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.write_vtk-Tuple{Any, Meshes.SimpleMesh}","page":"API","title":"Roentgen.write_vtk","text":"write_vtk(filename, mesh::SimpleMesh)\n\nSave a SimpleMesh to a VTK (.vtu) file.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.write_vtk-Tuple{String, DoseGrid, Vararg}","page":"API","title":"Roentgen.write_vtk","text":"write_vtk(filename::String, pos::DoseGrid, data::Union{Vararg, Dict})\n\nSave DoseGrid to the VTK Image data (vti) format.\n\n\n\n\n\n","category":"method"},{"location":"API/#Roentgen.write_vtk-Tuple{String, DoseGridMasked, Vararg}","page":"API","title":"Roentgen.write_vtk","text":"write_vtk(filename::String, pos::DoseGridMasked, data::Union{Vararg, Dict})\n\nSave DoseGridMasked to the VTK Unstructured Grid (vtu) format.\n\n\n\n\n\n","category":"method"},{"location":"DoseCalculationAlgorithms/#DoseAlgorithms","page":"Dose Calculation Algorithms","title":"Dose Calculation Algorithms","text":"","category":"section"},{"location":"DoseCalculationAlgorithms/","page":"Dose Calculation Algorithms","title":"Dose Calculation Algorithms","text":"Dose calculation algorithms specify how exactly to compute the dose at a given position from a given beamlet.","category":"page"},{"location":"DoseCalculationAlgorithms/","page":"Dose Calculation Algorithms","title":"Dose Calculation Algorithms","text":"To create a new dose calculation algorithm, it must be a subtype of Roentgen.AbstractDoseAlgorithm and implement the Roentgen.point_dose method. Machine specific parameters should be stored in the struct itself. This will allow the algorithm to be used with functions such as reconstruct_dose and dose_fluence_matrix","category":"page"},{"location":"DoseCalculationAlgorithms/","page":"Dose Calculation Algorithms","title":"Dose Calculation Algorithms","text":"MockKernel is a mock algorithm used as an example and for testing. Its implementation can be found in src/DoseCalculationAlgorithms/MockKernel.jl, where it implements a simple Roentgen.point_dose method.","category":"page"},{"location":"DoseCalculationAlgorithms/","page":"Dose Calculation Algorithms","title":"Dose Calculation Algorithms","text":"In addition to Roentgen.point_dose, it is recommended to implement a calibrate! method. This method calibrates the dose calculation to a given meterset value,","category":"page"},{"location":"DoseCalculationAlgorithms/","page":"Dose Calculation Algorithms","title":"Dose Calculation Algorithms","text":"calibrate!(calc, MU, fieldsize, SAD[, SSD=SAD])","category":"page"},{"location":"DoseCalculationAlgorithms/","page":"Dose Calculation Algorithms","title":"Dose Calculation Algorithms","text":"Scales the dose such that the maximum dose is 1 Gy for MU monitor units, given fieldsize and source-axis distance (SAD). The source-surface distance SSD can be set if SSD!=SAD.","category":"page"},{"location":"DoseCalculationAlgorithms/#Finite-Pencil-Beam-Kernel","page":"Dose Calculation Algorithms","title":"Finite Pencil Beam Kernel","text":"","category":"section"},{"location":"DoseCalculationAlgorithms/","page":"Dose Calculation Algorithms","title":"Dose Calculation Algorithms","text":"Implements the Jelen et al. 2005, \"A finite size pencil beam for IMRT dose optimization\" dose calculation kernel. All references to equations and variables refer to equations in the original paper.","category":"page"},{"location":"DoseCalculationAlgorithms/","page":"Dose Calculation Algorithms","title":"Dose Calculation Algorithms","text":"The FinitePencilBeamKernel struct stores machine dependent kernel parameters:","category":"page"},{"location":"DoseCalculationAlgorithms/","page":"Dose Calculation Algorithms","title":"Dose Calculation Algorithms","text":"parameters: 1D interpolator to obtain w_1, u_x and u_y at a given gepth\nscaling_factor: 2D interpolator to obtain A at a given depth and tanθ\nα_depth and α_tanθ: scaling factor to speed up interpolation","category":"page"},{"location":"DoseCalculationAlgorithms/","page":"Dose Calculation Algorithms","title":"Dose Calculation Algorithms","text":"The values for w_1, u_x, u_y and A are typically obtained from Monte-Carlo simulations or water tank data. Please refer to the original publication for detailed instructions.","category":"page"},{"location":"DoseCalculationAlgorithms/","page":"Dose Calculation Algorithms","title":"Dose Calculation Algorithms","text":"FinitePencilBeamKernel can be constructed either by directly providing the above parameters,","category":"page"},{"location":"DoseCalculationAlgorithms/","page":"Dose Calculation Algorithms","title":"Dose Calculation Algorithms","text":"calc = FinitePencilBeamKernel(parameters, scaling_factor, α_depth, α_tanθ)","category":"page"},{"location":"DoseCalculationAlgorithms/","page":"Dose Calculation Algorithms","title":"Dose Calculation Algorithms","text":"or by providing arrays for parameters, scaling_factor, depths and tanθ,","category":"page"},{"location":"DoseCalculationAlgorithms/","page":"Dose Calculation Algorithms","title":"Dose Calculation Algorithms","text":"calc = FinitePencilBeamKernel(parameters, scaling_factor, depths, tanθ)","category":"page"},{"location":"DoseCalculationAlgorithms/","page":"Dose Calculation Algorithms","title":"Dose Calculation Algorithms","text":"These parameters can also be loaded from a JLD2 filetype (based on the HDF5 standard),","category":"page"},{"location":"DoseCalculationAlgorithms/","page":"Dose Calculation Algorithms","title":"Dose Calculation Algorithms","text":"calc = FinitePencilBeamKernel(\"path/to/fpbk.jld2\")","category":"page"},{"location":"#Roentgen.jl","page":"Roentgen.jl","title":"Roentgen.jl","text":"","category":"section"},{"location":"","page":"Roentgen.jl","title":"Roentgen.jl","text":"This is a Julia package for computing radiotherapy doses. The aim of this package is to provide a general and extensible means to include dose calculations into research. Examples of this include:","category":"page"},{"location":"","page":"Roentgen.jl","title":"Roentgen.jl","text":"Novel treatment planning methods\nDose-based adaptive radiotherapy\nDosimetric assessment of adaptive radiotherapy","category":"page"},{"location":"","page":"Roentgen.jl","title":"Roentgen.jl","text":"(Image: dose_recon_example)","category":"page"},{"location":"DoseVolume/#DoseVolumes","page":"Dose Volumes","title":"Dose Volumes","text":"","category":"section"},{"location":"DoseVolume/","page":"Dose Volumes","title":"Dose Volumes","text":"Dose volumes comprise of two objects, Dose Positions and External Surfaces.","category":"page"},{"location":"DoseVolume/","page":"Dose Volumes","title":"Dose Volumes","text":"Dose positions are essentially lists of points in 3D space where dose is computed. The external surface is used to compute source-surface distances and depths.","category":"page"},{"location":"DoseVolume/","page":"Dose Volumes","title":"Dose Volumes","text":"Dose volumes, stored in DoseVolume, are constructed by first constructing the dose positions and external surfaces. They can then be used in various computations.","category":"page"},{"location":"DoseVolume/","page":"Dose Volumes","title":"Dose Volumes","text":"vol = DoseVolume(pos, surf)","category":"page"},{"location":"Structures/#Structures","page":"Structures","title":"Structures","text":"","category":"section"},{"location":"Structures/","page":"Structures","title":"Structures","text":"Dose volumes often contain structures of interest (e.g. the PTV or an OAR) where one may want to compute dose, or determine various metrics.","category":"page"},{"location":"Structures/","page":"Structures","title":"Structures","text":"This section describes how to use structures to:","category":"page"},{"location":"Structures/","page":"Structures","title":"Structures","text":"Load structures from file.\nCreate dose points within a given structure \nTag dose points based on which structure they are in.","category":"page"},{"location":"Structures/#Creating-Structures","page":"Structures","title":"Creating Structures","text":"","category":"section"},{"location":"Structures/","page":"Structures","title":"Structures","text":"One can load a mesh file using load_structure_from_ply. Currently, only .ply files are supported.","category":"page"},{"location":"Structures/","page":"Structures","title":"Structures","text":"structure = load_structure_from_ply(\"mesh.ply\")","category":"page"},{"location":"Structures/","page":"Structures","title":"Structures","text":"This returns a Meshes.SimpleMesh, as provided by Meshes.jl.","category":"page"},{"location":"Structures/","page":"Structures","title":"Structures","text":"Currently, loading structures direct from a DICOM RT Structure Set is not supported. Structures stored in DICOM files are not in a \"friendly\" mesh format, and usually require some modification before they can be used. There are many tools available which convert DICOM structures into a suitable mesh file (e.g. 3D Slicer).","category":"page"},{"location":"Structures/#Coordinate-Transformations","page":"Structures","title":"Coordinate Transformations","text":"","category":"section"},{"location":"Structures/","page":"Structures","title":"Structures","text":"One can apply general transformations to any structure by calling the transform or transform! function:","category":"page"},{"location":"Structures/","page":"Structures","title":"Structures","text":"T = fixed_to_bld(0., 0., 1000.)\ntransform(structure, T)","category":"page"},{"location":"Structures/","page":"Structures","title":"Structures","text":"T is a general transformation as provided by CoordinateTransformations.jl. In this example, the helper function fixed_to_bld is used to create a transformation from the IEC Fixed to IEC BLD coordinate system. See Coordinate Transformations for more details.","category":"page"}]
}
