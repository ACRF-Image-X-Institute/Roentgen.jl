#=
    Commissioning a beam for the Finite Pencil Beam Kernel

This script will commission a beam for the `FinitePencilBeamKernel` dose calculation
algorithm. It reads water phantom data from "examples/sample-data/water-tank-dose.hdf5",
which is either measured by experiment, or generated by a Monte-Carlo simulation.
It stores the commissioned kernel in "examples/sample-data/dose-kernel/finite-pencil-beam-kernel.hdf5"
=#

using DoseCalculations
using Plots, StaticArrays
using Interpolations, LsqFit, HDF5
using Statistics

#--- Set Parameters ------------------------------------------------------------

SSD = 1000.
SAD = SSD
fieldsize = 100.

#---  Load Data ----------------------------------------------------------------

begin
    dosefilepath = "examples/sample-data/water-tank-dose.hdf5"
    x, depth, measured_dose = h5open(dosefilepath, "r") do fid
        x = read(fid["x"])
        z = read(fid["depth"])
        dose = read(fid["dose/fieldsize-$(Int(fieldsize))mm"])
        
        x, z, dose
    end
end

heatmap(x, depth, measured_dose', title="Measured Dose",
        xlabel="Off-Axis Position (mm)", ylabel="Depth (mm)")

#--- Fit Steepness and Weight Parameters ---------------------------------------

# Scale offaxis dose profiles by dose along the central axis
ix = searchsortedfirst(x, 0.)
measured_dose_scaled = measured_dose./measured_dose[ix, :]'

heatmap(x, depth, measured_dose_scaled', title="Measured Dose (Scaled)",
        xlabel="Off-Axis Position (mm)", ylabel="Depth (mm)")

# Scale off-axis position to iso-center
x′ = @. x*SAD/(SAD+depth')
begin
    p = plot(ylabel="Dose (Scaled)", xlabel=xlabel="Scaled Off-Axis Position (mm)")
    for i in axes(measured_dose_scaled, 2)
        plot!(p, x′[:, i], measured_dose_scaled[:, i], label="")
    end
    p
end

# Create Model

profile_at_depth(x, w, ux, x₀) = DoseCalculations.fpbk_dose(x, 0., w, ux, ux, x₀, x₀)

function model(x, p, fieldsize)
    a = p[1]
    w = p[2]
    ux = @view p[3:4]

    a*profile_at_depth.(x, w, Ref(ux), 0.5*fieldsize)
end

# Least Squares Fit

function fit_profile(x′, measured_dose, fieldsize)
    # p0 = rand(4) # fill(0.5, 4)
    p0 = [1., 0.2, 0.03, 0.4]

    lb = [-Inf, 0., 0., 0.]
    ub = [Inf, 1., Inf, Inf]


    fit = curve_fit((x, p)->model(x, p, fieldsize),
                    x′, measured_dose, p0,
                    lower=lb, upper=ub)

    !fit.converged && return fill(NaN, 4), fill(NaN, 4)

    a, w, ux1, ux2 = fit.param
    errors = standard_errors(fit)
    if(ux1>ux2)
        w = 1-w
        ux1, ux2 = ux2, ux1
    end
    [a, w, ux1, ux2], errors
end

# Fit parameters

params = zeros(4, length(depth))
errors = zeros(4, length(depth))
for i in axes(params, 2)
    p, ε = fit_profile(x′[:, i], measured_dose_scaled[:, i], fieldsize)
    params[:, i] .= p
    errors[:, i] .= ε
end

begin
    i = 25
    ylabels = ["a", "w", "ux₁", "ux₂"]
    p = [plot(depth, params[i, :], yerr=errors[i, :], legend=false, ylabel=ylabels[i]) for i in axes(params, 1)]
    for pᵢ in p
        vline!(pᵢ, depth[[i]], xlabel="Scaled Off-Axis Pos. (mm)")
    end
    plot(p..., layout=grid(2, 2), figheight=(12, 5))
end

begin
    i = 25
    p = plot(xlabel="Scaled Off-Axis Position (mm)", ylabel="Dose (Scaled)")
    plot!(p, x′[:, i], measured_dose_scaled[:, i], label="Measured")
    xᵢ′ = x′[1, i]:1.:x′[end, i]
    plot!(p, xᵢ′, params[1, i]*profile_at_depth.(xᵢ′, params[2, i], Ref(params[3:4, i]), 0.5*fieldsize),
          label="Fitted")
end

#--- Smooth Steepness and Weight Parameters ------------------------------------

function moving_average(x::Vector, window_size)
    @assert window_size%2==1 "Window size must be odd"

    xnew = similar(x)
    error = similar(x)
    window = zeros(window_size)

    hn = window_size÷2+1

    window[1:hn] .= x[1]
    window[hn+1:end] .= x[2:hn]

    for i in eachindex(x)
        σ² = var(window)
        x̄ = mean(window)
        I = @. (window-x̄)^2<=σ²

        xnew[i] = mean(window[I])
        error[i] = std(window[I])
        
        window[1:end-1] .= window[2:end]
        window[end] = x[min(length(x), i+hn)]

    end

    xnew, error
end

function moving_average(x::Matrix, window_size)
    xsmooth = similar(x)
    error = similar(x)

    for i in axes(x, 1)
        xᵢ, εᵢ = moving_average(x[i, :], window_size)
        xsmooth[i, :] .= xᵢ
        error[i, :] .= εᵢ
    end

    xsmooth, error
end

params_smoothed, _ = moving_average(params, 11)

begin
    ylabels = ["a", "w", "ux₁", "ux₂"]
    ymax = [Inf, 1., 0.1, 1.]
    p = []
    for i in axes(params, 1)
        pᵢ = plot(depth, params[i, :], yerr=errors[i, :], legend=false, ylabel=ylabels[i])
        plot!(depth, params_smoothed[i, :])
        plot!(ylim=[0., ymax[i]])
        push!(p, pᵢ)
    end
    plot(p..., layout=grid(4, 1), size=(800, 1200))
end

#--- Compute Scaling Factor ---------------------------------------------------

R = @. depth + SAD

Rmax = depth[end]+SAD
xmax = maximum(abs.(x))

tanθmax = xmax/Rmax

tanθ = range(0., tanθmax, length=201)

function scaling_factor(d, tanθ, R, D, param)

    secθ = √(tanθ^2 + 1)

    pos_depth = d*secθ#/cos(θ)
    pos_dist = R*secθ#/cos(θ)
    pos_offaxis_dist = R*tanθ

    w, ux1, ux2 = param(pos_depth)

    F = profile_at_depth(pos_offaxis_dist, w, [ux1, ux2], 0.5*fieldsize)
    
    exp(D(pos_offaxis_dist))*pos_dist^2/F
end

p = SVector{3}.(eachcol(params_smoothed[2:4, :]))
p = linear_interpolation(depth, p, extrapolation_bc=Flat())

D = linear_interpolation.(Ref(x), eachcol(log.(measured_dose)), extrapolation_bc=Line())

A = scaling_factor.(depth, tanθ', R, D, Ref(p))

heatmap(rad2deg.(atan.(tanθ)), depth, A, xlabel="θ (°)", ylabel="Depth (mm)")

I = linear_interpolation((depth, tanθ), A, extrapolation_bc=Flat())

# Create Kernel
parameters = vcat(params_smoothed[2:end, :], params_smoothed[3:4, :])

calc = FinitePencilBeamKernel(depth, parameters, tanθ, A; maxradius=280.)

pos = @. SVector(x, x[ix], -depth')
surf = PlaneSurface(SSD)
beamlets = [Beamlet(Bixel(0., fieldsize), GantryPosition(0., 0., SAD))]

dose = Array(dose_fluence_matrix(vec(pos), beamlets, surf, calc))
dose = reshape(dose, size(pos)...)

# Plot Result

heatmap(x, depth, dose'/maximum(dose), xlabel="x (mm)", ylabel="Depth (mm)", title="Computed Dose", aspect_ratio=1,
        xlim=x[[1, end]], ylim=depth[[1, end]])
heatmap(x, depth, measured_dose'/maximum(measured_dose), xlabel="x (mm)", ylabel="Depth (mm)", title="Measured Dose", aspect_ratio=1,
        xlim=x[[1, end]], ylim=depth[[1, end]])

begin
    plot(depth, dose[ix, :]/maximum(dose[ix, :]), label="Computed", xlabel="Depth (mm)", ylabel="Dose")
    plot!(depth, measured_dose[ix, :]/maximum(measured_dose[ix, :]), label="Measured")
end

begin
    idepth = searchsortedlast(depth, 100.)
    plot(x, dose[:, idepth]/maximum(dose[:, idepth]), label="Computed", xlabel="x (mm)", ylabel="Dose")
    plot!(x, measured_dose[:, idepth]/maximum(measured_dose[:, idepth]), label="Measured")
end


#--- Save to File --------------------------------------------------------------

h5open("examples/sample-data/dose-kernel/finite-pencil-beam-kernel.hdf5", "w") do fid

    group = create_group(fid, "fieldsize-$(Int(fieldsize))mm")

    attributes(group)["fieldsize"] = fieldsize

    group["parameters"] = parameters
    group["depth"] = depth
    group["scaling_factor"] = A
    group["tan_theta"] = collect(tanθ)
end
